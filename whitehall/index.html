<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8">
        <meta name ="viewport" content="width=device-width, initial-scale=1.0">
        <title>Whitehall</title>
<style>
body {
    margin: 0;
    overflow: hidden;
}
</style>
    </head>

    <body>
        <canvas id="myCanvas"></canvas>

        <script src="graph.js"></script>
        <script>
// TODO: reorder nodes feature
// TODO: neighbors array should be Set()
// TODO: can detectives move past each other?

const detectiveColors = [
    { normal: "hsl(60,    80%, 60%)", selected: "hsl(60,    80%, 80%)"  },
    { normal: "hsl(240,   80%, 60%)", selected: "hsl(240,   80%, 80%)"  },
    { normal: "hsl(0,     80%, 60%)", selected: "hsl(0,     80%, 80%)"  },
];

const actionStack = [];
const redoStack = [];

const errorNodes = new Set();

const canvas = document.getElementById('myCanvas');
const ctx = canvas.getContext('2d');

let scaleFactor = 80;

const fixed_dt = 8; // 125 Hz
const MAX_FRAMETIME = 250;

const LEFT_BUTTON   = 0;
const RIGHT_BUTTON  = 2;

const TURN_JACK_START       = 0;
const TURN_DET_START        = 1;
const TURN_FIRST_MURDER     = 2;
const TURN_JACKMOVE         = 3;
const TURN_DETMOVE          = 4;
const TURN_CLUES            = 5;
const TURN_JACK_WINS        = 6;
const TURN_DETECTIVES_WIN   = 7;

const ACTION_NONE   = 0;
const ACTION_CLUES  = 1;
const ACTION_ARREST = 2;

let editorMode = false;
let clickedNodeIndex = null;
let clickedNodeOriginalPos;
let rightClickedNodeIndex = null;
let mouseX = 0;
let mouseY = 0;

let width;
let height;
let accumulator;
let simRate;
let prevTime;

let selectedDetective = null;

let cs = {};
let ss = {};

let inputsToSim = {
    // 160 : [ { key: 'ArrowDown',   mode: 'down'   }, ],
};

function saveState() {
    ss = JSON.parse(JSON.stringify(cs));
}

function restoreState() {
    cs = JSON.parse(JSON.stringify(ss));
}

function makeGraphConsistent() {
    // if A->B then B->A
    for (const [nodeIndex, node] of graph.entries()) {
        for (const neighborIndex of node.neighbors) {
            const neighborNode = graph[neighborIndex];
            if (!neighborNode.neighbors.includes(nodeIndex)) {
                neighborNode.neighbors.push(nodeIndex);
            }
        }
    }
}

function validateGraph() {

    errorNodes.clear();

    let returnValue = true;

    // if A->B then B->A
    for (const [nodeIndex, node] of graph.entries()) {
        for (const neighborIndex of node.neighbors) {
            const neighborNode = graph[neighborIndex];
            if (!neighborNode.neighbors.includes(nodeIndex)) {
                console.error(`${nodeIndex}->${neighborIndex} but not ${neighborIndex}->${nodeIndex}`);
                errorNodes.add(nodeIndex);
                errorNodes.add(neighborIndex);
                returnValue = false;
            }
        }
    }

    // no A->A
    for (const [nodeIndex, node] of graph.entries()) {
        if (node.neighbors.includes(nodeIndex)) {
            console.error(`${nodeIndex}->${nodeIndex}`);
            errorNodes.add(nodeIndex);
            returnValue = false;
        }
    }

    // no Jack->Jack
    for (const [nodeIndex, node] of graph.entries()) {
        if (node.type != 'j')
            continue;
        for (const neighborIndex of node.neighbors) {
            const neighborNode = graph[neighborIndex];
            if (neighborNode.type == 'j') {
                console.error(`Jack->Jack: ${nodeIndex}->${neighborIndex}`);
                errorNodes.add(nodeIndex);
                errorNodes.add(neighborIndex);
                returnValue = false;
            }
        }
    }

    // no repeated neighbors
    for (const [nodeIndex, node] of graph.entries()) {
        if (hasDuplicates(node.neighbors)) {
            console.error(`node ${nodeIndex} has duplicate neighbors: ${node.neighbors}`);
            errorNodes.add(nodeIndex);
            returnValue = false;
        }
    }

    // no nodes with zero neighbors
    for (const [nodeIndex, node] of graph.entries()) {
        if (nodeIndex == 0)
            continue;
        if (node.neighbors.length == 0) {
            console.error(`${nodeIndex} has zero neighbors`);
            errorNodes.add(nodeIndex);
            returnValue = false;
        }
    }

    // no non-boat Jack nodes with fewer than 2 neighbors
    for (const [nodeIndex, node] of graph.entries()) {
        if (node.type != 'j' || node.boat)
            continue;
        if (node.neighbors.length < 2) {
            console.error(`non-boat Jack node ${nodeIndex} has fewer than 2 neighbors`);
            errorNodes.add(nodeIndex);
            returnValue = false;
        }
    }

    // no detective nodes with fewer than 2 neighbors
    for (const [nodeIndex, node] of graph.entries()) {
        if (node.type != 'd')
            continue;
        if (node.neighbors.length < 2) {
            console.error(`detective node ${nodeIndex} has fewer than 2 neighbors`);
            errorNodes.add(nodeIndex);
            returnValue = false;
        }
    }

    return returnValue;
}

function reset() {
    accumulator = 0;
    simRate = 1.0;
    prevTime = 0;

    cs =  {
        turn: TURN_JACK_START,
        round: 0,
        chosenLocations: [0, 0, 0, 0], // [32, 46, 147, 120],
        jack: {
            moves: [],
            location: null
        },
        detectives: [
            { location: null, /*275*/ moved: false, acted: false, checked: [] },
            { location: null, /*298*/ moved: false, acted: false, checked: [] },
            { location: null, /*279*/ moved: false, acted: false, checked: [] },
        ],
        action: ACTION_NONE,
        clues: {},
        murders: []
    };
    saveState();

    //makeGraphConsistent();
    if (!validateGraph()) {
        console.error('invalid graph');
    }

    resize();
}

reset();

function newNode(type, x, y, index) {

    // default to current mouse position
    x ??= round(mouseX/scaleFactor, 1);
    y ??= round(mouseY/scaleFactor, 1);

    // default insertion index
    if (type == 'j') {
        const indexOfLastJackNode = graph.filter(x => x.type == 'j').length;
        index ??= indexOfLastJackNode+1;
    } else if (type == 'd') {
        index ??= graph.length;
    }

    // adjust neighbor indices for existing nodes
    for (const node of graph) {
        node.neighbors.forEach((item, itemIndex, arr) => {
            if (item >= index) {
                arr[itemIndex]++;
            }
        });
    }

    // insert new node
    if (type == 'j') {
        graph.splice(index, 0, { "type": "j", "pos": { "x": x, "y": y }, "quadrant": 0, "neighbors": [ ], "boat": false });
    } else if (type == 'd') {
        graph.splice(index, 0, { "type": "d", "pos": { "x": x, "y": y }, "starting": false, "neighbors": [ ] });
    }

    return index;
}

function connectNodes(a, b) {
    graph[a].neighbors.push(b);
    graph[b].neighbors.push(a);
}

function disconnectNodes(a, b) {
    removeItemOnce(graph[a].neighbors, b);
    removeItemOnce(graph[b].neighbors, a);
}

function deleteNode(nodeIndex) {
    const toDisonnect = [...graph[nodeIndex].neighbors];
    toDisonnect.forEach(neighborIndex => disconnectNodes(nodeIndex, neighborIndex));
    for (const node of graph) {
        node.neighbors.forEach((item, index, arr) => {
            if (item > nodeIndex) {
                arr[index]--;
            }
        });
    }
    graph.splice(nodeIndex, 1);
}

function undo() {
    if (actionStack.length == 0)
        return;
    const action = actionStack.pop();
    if (action.type == 'move') {
        Object.assign(graph[action.nodeIndex].pos, action.from);
    } else if (action.type == 'connect') {
        disconnectNodes(action.src, action.dst);
    } else if (action.type == 'disconnect') {
        connectNodes(action.src, action.dst);
    } else if (action.type == 'newNode') {
        deleteNode(action.index);
    } else if (action.type == 'deleteNode') {
        newNode(action.nodeType, action.pos.x, action.pos.y, action.index);
        action.neighbors.forEach(neighborIndex => connectNodes(action.index, neighborIndex));
    }
    redoStack.push(action);
}

function redo() {
    if (redoStack.length == 0)
        return;
    const action = redoStack.pop();
    if (action.type == 'move') {
        Object.assign(graph[action.nodeIndex].pos, action.to);
    } else if (action.type == 'connect') {
        connectNodes(action.src, action.dst);
    } else if (action.type == 'disconnect') {
        disconnectNodes(action.src, action.dst);
    } else if (action.type == 'newNode') {
        newNode(action.nodeType, action.pos.x, action.pos.y);
    } else if (action.type == 'deleteNode') {
        deleteNode(action.index);
    }
    actionStack.push(action);
}

function px(x, f=0.0) { return Math.round(x) + f; }

function removeItemOnce(arr, value) {
    const index = arr.indexOf(value);
    if (index > -1) {
        arr.splice(index, 1);
    }
    return arr;
}

function hasDuplicates(array) {
    return (new Set(array)).size !== array.length;
}

function round(value, precision) {
    const multiplier = Math.pow(10, precision || 0);
    return Math.round(value * multiplier) / multiplier;
}

function isAtoZ(s) {
    return (s.length == 1 && s >= 'a' && s <= 'z');
}

function ord(c) {
    if (!isAtoZ(c)) {
        console.error(`invalid input to ord(): ${c}`);
        return undefined;
    }
    return c.charCodeAt(0) - "a".charCodeAt(0);
}

function toLetter(x) {
    if (x < 0 || x > 25) {
        console.error(`invalid input to toLetter(): ${x}`);
        return undefined;
    }
    return `${String.fromCharCode(x + "a".charCodeAt(0))}`;
}

function drawRect(sr)
{
    ctx.fillRect(px(sr.x - sr.w/2), px(sr.y - sr.h/2), sr.w, sr.h);
}

function drawText(text, params) {
    params              ??= {}
    params.fontSize     ??= 40;
    params.font         ??= "Calibri";
    params.lineWidth    ??= 2;
    params.fillStyle    ??= "white";
    params.strokeStyle  ??= "black";
    params.fill         ??= true;
    params.stroke       ??= true;
    params.bold         ??= false;
    ctx.font        = (params.bold ? "bold " : "") + `${params.fontSize}px ${params.font}`;
    ctx.lineWidth   = params.lineWidth;
    ctx.fillStyle   = params.fillStyle;
    ctx.strokeStyle = params.strokeStyle;
    params.x            ??= width/2 - ctx.measureText(text).width/2;
    params.y            ??= height/2 + params.fontSize/3;
    if (params.fill)
        ctx.fillText(text, params.x, params.y);
    if (params.stroke)
        ctx.strokeText(text, params.x, params.y);
}

function adjacentJackNodes(location, ignoreDetectives=false) {
    const adjacent = new Set();
    const visited = new Set();
    const queue = [];
    visited.add(cs.jack.location);
    queue.unshift(cs.jack.location);
    while (queue.length > 0) {
        const x = queue.pop();
        graph[x].neighbors.forEach(ni => {
            if (graph[ni].type == 'd' && !visited.has(ni)) {
                if (cs.detectives.every(d => d.location != ni) || ignoreDetectives) {
                    visited.add(ni);
                    queue.unshift(ni);
                }
            } else {
                adjacent.add(ni);
            }
        });
    }
    adjacent.delete(location); // jack cannot stay put
    return Array.from(adjacent);
}

function getMovesForJack() {
    if (cs.jack.location == null)
        return [];
    return adjacentJackNodes(cs.jack.location);
}

function detNodesWithinN(location, n) {
    const withinN = new Set();
    if (n <= 0 || location == null)
        return [];
    for (const neighborIndex of graph[location].neighbors) {
        if (graph[neighborIndex].type == 'd') {
            withinN.add(neighborIndex);
            detNodesWithinN(neighborIndex, n-1).forEach(item => withinN.add(item));
        } else if (graph[neighborIndex].type == 'j') {
            for (const neighborIndex2 of graph[neighborIndex].neighbors) {
                withinN.add(neighborIndex2);
                detNodesWithinN(neighborIndex2, n-1).forEach(item => withinN.add(item));
            }
        }
    }
    return Array.from(withinN);
}

function getMovesForDetective(detective) {
    let moves = [];
    if (detective != null && !cs.detectives[detective].moved) {
        moves = detNodesWithinN(cs.detectives[detective].location, 2);
        // cannot move where another detective is
        for (let di = 0; di < 3; di++) {
            if (di == detective)
                continue;
            removeItemOnce(moves, cs.detectives[di].location);
        }
    }
    return moves;
}

function getClueOptions(detective) {
    if (selectedDetective == null ||
        cs.detectives[selectedDetective].acted ||
        cs.detectives[selectedDetective].location == null)
        return [];
    return graph[cs.detectives[selectedDetective].location].neighbors.filter(n => graph[n].type == 'j');
}

function proceedIfAllDetectivesHaveActed() {
    if (cs.detectives.every(d => d.acted)) {
        cs.detectives.forEach(d => {
            d.moved = false;
            d.acted = false;
            d.checked = [];
        });
        cs.turn = TURN_JACKMOVE;
        // TODO: make it clear that a murder has happened
        if (cs.chosenLocations.includes(cs.jack.location) && !cs.murders.includes(cs.jack.location)) {
            cs.murders.push(cs.jack.location);
            cs.round++;
            cs.jack.moves = [];
            cs.clues = {};
        } else if (getMovesForJack().length == 0) {
            // TODO: unless special abilities allow him to escape
            cs.turn = TURN_DETECTIVES_WIN;
        } else if (cs.jack.moves.length >= 15) {
            cs.turn = TURN_DETECTIVES_WIN;
        }
        if (cs.round == 4) {
            cs.turn = TURN_JACK_WINS;
        }
    }
}

function chooseClue(choice) {
    const clueOptions = getClueOptions(selectedDetective);
    if (!clueOptions.includes(choice)) {
        return;
    }
    if (!cs.detectives[selectedDetective].checked.includes(choice)) {
        const numVisits = cs.jack.moves.filter(m => m == choice).length;
        if (numVisits > 0) {
            // detective cannot continue looking for clues if new clues are found
            if (!(choice in cs.clues) || cs.clues[choice] < numVisits) {
                cs.detectives[selectedDetective].acted = true;
            }
            cs.clues[choice] = numVisits;
        }
        cs.detectives[selectedDetective].checked.push(choice);
        if (cs.detectives[selectedDetective].checked.length == clueOptions.length) {
            cs.detectives[selectedDetective].acted = true;
        }
    }
    // selected the next detective
    if (cs.detectives[selectedDetective].acted) {
        selectedDetective++;
        if (selectedDetective > 2)
            selectedDetective = null;
    }
    proceedIfAllDetectivesHaveActed();
}

function arrestOn(choice) {
    if (cs.jack.location == choice) {
        cs.turn = TURN_DETECTIVES_WIN;
        return;
    }
    cs.detectives[selectedDetective].acted = true;
    selectedDetective++;
    if (selectedDetective > 2)
        selectedDetective = null;
    cs.action = ACTION_CLUES;
    proceedIfAllDetectivesHaveActed();
}

function chooseStartingLocation(choice) {
    cs.detectives[selectedDetective].location = choice;
    selectedDetective++
    if (selectedDetective > 2) {
        selectedDetective = null;
        cs.turn = TURN_FIRST_MURDER;
    }
}

function draw() {
    ctx.clearRect(0, 0, width, height);

    ctx.fillStyle = "hsl(28, 60%, 75%)";
    ctx.fillRect(0, 0, width, height);

    // draw grid
    ctx.lineWidth = 1;
    ctx.strokeStyle = "hsl(0, 0%, 50%)";
    for (let c = 0; c < 12; c++) {
        ctx.beginPath();
        ctx.moveTo(px(c*scaleFactor, 0.5), 0);
        ctx.lineTo(px(c*scaleFactor, 0.5), 12*scaleFactor);
        ctx.stroke();
    }
    for (let r = 0; r < 12; r++) {
        ctx.beginPath();
        ctx.moveTo(0,               px(r*scaleFactor, 0.5));
        ctx.lineTo(12*scaleFactor,  px(r*scaleFactor, 0.5));
        ctx.stroke();
    }

    const hoverNodeIdx = getNodeNear(mouseX, mouseY);
    const startingNodes = graph.map((n, index) => { return {index: index, n: n}; }).filter(e => e.n.starting).map(e => e.index);
    const clueOptions = getClueOptions(selectedDetective);
    const availDetMoves = getMovesForDetective(selectedDetective);
    const availJackMoves = getMovesForJack();

    // TODO: make the following clear:
    // - murder locations
    // - clues
    // - jack's current position
    // - clue option for detective
    // - move option for detective
    // - move option for jack

    // draw Jack Graph
    for (const [nodeIndex, jackNode] of graph.entries()) {
        if (jackNode.type != 'j')
            continue;
        // skip dummy node
        if (nodeIndex == 0)
            continue;

        // draw lines to detective nodes
        ctx.lineWidth = 2;
        ctx.strokeStyle = "black";
        ctx.setLineDash([5, 5]);
        for (const detNodeIndex of jackNode.neighbors) {
            const detNode = graph[detNodeIndex];
            if (detNode === undefined) {
                continue;
            }
            ctx.beginPath();
            ctx.moveTo(
                jackNode.pos.x*scaleFactor,
                jackNode.pos.y*scaleFactor,
            );
            ctx.lineTo(detNode.pos.x*scaleFactor, detNode.pos.y*scaleFactor);
            ctx.stroke();
        }
        ctx.setLineDash([]);

        // circle
        ctx.strokeStyle = "black";
        ctx.fillStyle = jackNode.quadrant == 0 ? "black" : "white";
        if (jackNode.boat) ctx.fillStyle = "skyblue";
        // === BEGIN FOR DEBUG ===
        //if (jackNode.quadrant == 1)         { ctx.fillStyle = "red"; }
        //else if (jackNode.quadrant == 2)    { ctx.fillStyle = "green"; }
        //else if (jackNode.quadrant == 3)    { ctx.fillStyle = "blue"; }
        //else if (jackNode.quadrant == 4)    { ctx.fillStyle = "purple"; }
        if (hoverNodeIdx == nodeIndex) ctx.fillStyle = "orange";
        if (errorNodes.has(nodeIndex)) ctx.fillStyle = "red";
        // === END  FOR DEBUG ===
        ctx.beginPath();
        ctx.arc(
            jackNode.pos.x*scaleFactor,
            jackNode.pos.y*scaleFactor,
            0.14*scaleFactor,
            0, Math.PI*2
        );
        ctx.stroke();
        ctx.fill();

        // show jack's current location
        if (cs.turn == TURN_JACKMOVE && cs.jack.location == nodeIndex) {
            ctx.lineWidth = 6;
            ctx.strokeStyle = "purple";
            ctx.stroke();
        }

        // show jack's available moves
        if (cs.turn == TURN_JACKMOVE && availJackMoves.includes(nodeIndex)) {
            ctx.strokeStyle = "red";
            ctx.stroke();
        }

        // show options for choosing first murder location
        if (cs.turn == TURN_FIRST_MURDER && cs.chosenLocations.includes(nodeIndex)) {
            ctx.strokeStyle = "red";
            ctx.stroke();
        }

        // show options for checking for clues
        if (selectedDetective != null) {
            const alreadyChecked = cs.detectives[selectedDetective].checked.includes(nodeIndex);
            if (cs.turn == TURN_CLUES && clueOptions.includes(nodeIndex)) {
                ctx.lineWidth = 2;
                ctx.strokeStyle = "red";
                if (!alreadyChecked)
                    ctx.stroke();
            }
        }

        // show found clues
        // TODO: indicate how many clues are on a location
        if (nodeIndex in cs.clues) {
            ctx.fillStyle = "hsla(60, 80%, 50%, 0.7)";
            ctx.fill();
        }

        // show chosen locations
        if (cs.turn == TURN_JACK_START || cs.turn == TURN_FIRST_MURDER || cs.turn == TURN_JACKMOVE) {
            if (cs.chosenLocations.includes(nodeIndex)) {
                ctx.fillStyle = "hsla(0, 80%, 50%, 0.7)";
                ctx.fill();
            }
        }

        // show murders
        if (cs.murders.includes(nodeIndex)) {
            ctx.fillStyle = "hsla(0, 80%, 50%, 0.7)";
            ctx.fill();
        }

        // jack node number
        ctx.fillStyle = jackNode.quadrant == 0 ? "white" : "black";
        ctx.font = `bold ${Math.floor(scaleFactor/6)}px Arial`;
        ctx.fillText(
            `${nodeIndex}`,
            jackNode.pos.x*scaleFactor - ctx.measureText(`${nodeIndex}`).width/2,
            jackNode.pos.y*scaleFactor + scaleFactor/20
        );
    }

    // draw detective graph
    for (const [detNodeIndex, detNode] of graph.entries()) {
        if (detNode.type != 'd')
            continue;

        // === BEGIN FOR DEBUG ===
        if ((detNode.pos.x == 0) && (detNode.pos.y == 0)) {
            detNode.pos.x = 1 + ((detNodeIndex-189) % 20) * 0.5;
            detNode.pos.y = 8.5 + Math.floor((detNodeIndex-189) / 20) * 0.5;
        }
        // === END   FOR DEBUG ===

        // draw lines to detective nodes
        ctx.lineWidth = 2;
        ctx.strokeStyle = "black";
        ctx.setLineDash([5, 5]);
        for (const neighborIndex of detNode.neighbors) {
            if (neighborIndex < detNodeIndex)
                continue; // draw only one line (A->B, skip B->A)
            const detNode2 = graph[neighborIndex];
            if (detNode2 === undefined) {
                continue;
            }
            ctx.beginPath();
            ctx.moveTo(
                detNode.pos.x*scaleFactor,
                detNode.pos.y*scaleFactor,
            );
            ctx.lineTo(detNode2.pos.x*scaleFactor, detNode2.pos.y*scaleFactor);
            ctx.stroke();
        }
        ctx.setLineDash([]);

        // square
        ctx.beginPath();
        ctx.rect(
            detNode.pos.x*scaleFactor - scaleFactor/20,
            detNode.pos.y*scaleFactor - scaleFactor/20,
            scaleFactor/10,
            scaleFactor/10
        );

        // starting nodes for detectives
        if (cs.turn == TURN_DET_START && detNode.starting) {
            ctx.lineWidth = 6;
            ctx.strokeStyle =  "gold";
            ctx.stroke();
        }

        ctx.fillStyle = "black";
        if (hoverNodeIdx == detNodeIndex) ctx.fillStyle = "orange";
        if (errorNodes.has(detNodeIndex)) ctx.fillStyle = "red";
        ctx.fill();

        // label available detective moves
        if (selectedDetective != null && cs.turn == TURN_DETMOVE && availDetMoves.includes(detNodeIndex)) {
            ctx.lineWidth = 2;
            ctx.strokeStyle = "white";
            ctx.stroke();
        }

        // === BEGIN FOR DEBUG ===
        // node label
        if (editorMode && hoverNodeIdx == detNodeIndex) {
            ctx.fillStyle = "red";
            ctx.font = `bold ${Math.floor(scaleFactor/6)}px Arial`;
            ctx.fillText(
                `${detNodeIndex-0}`,
                detNode.pos.x*scaleFactor - scaleFactor/20,
                detNode.pos.y*scaleFactor - scaleFactor/10
            );
        }
        // === END   FOR DEBUG ===
    }

    // draw new line from right-click
    if (editorMode && rightClickedNodeIndex != null) {
        ctx.lineWidth = 2;
        ctx.strokeStyle = "black";
        ctx.setLineDash([5, 5]);
        ctx.beginPath();
        ctx.moveTo(
            graph[rightClickedNodeIndex].pos.x*scaleFactor,
            graph[rightClickedNodeIndex].pos.y*scaleFactor,
        );
        ctx.lineTo(mouseX, mouseY);
        ctx.stroke();
        ctx.setLineDash([]);
    }

    // detectives
    ctx.lineWidth = 2;
    for (const [detNum, detective] of cs.detectives.entries()) {
        if (detective.location === null)
            continue;
        const detPos = graph[detective.location].pos;
        ctx.beginPath();
        ctx.rect(
            detPos.x*scaleFactor - scaleFactor/8,
            detPos.y*scaleFactor - scaleFactor/8,
            scaleFactor/4,
            scaleFactor/4
        );
        ctx.fillStyle   = (selectedDetective == detNum) ? detectiveColors[detNum].selected : detectiveColors[detNum].normal;
        ctx.strokeStyle = (selectedDetective == detNum) ? "white" : "black";
        ctx.fill();
        ctx.stroke();
    }

    // node labels
    for (const [nodeIndex, node] of graph.entries()) {

        // label for choosing murder location
        if (cs.turn == TURN_FIRST_MURDER && cs.chosenLocations.includes(nodeIndex)) {
            const label = `${cs.chosenLocations.indexOf(nodeIndex)+1}`;
            drawText(label, {
                x: node.pos.x*scaleFactor - ctx.measureText(label).width/2,
                y: node.pos.y*scaleFactor - scaleFactor/5,
                fontSize: Math.floor(scaleFactor/3),
                font: "Arial",
                fillStyle: "orange",
                strokeStyle: "red",
                lineWidth: 2,
                bold: true
            });
        }

        // labels for jack's available moves
        if (cs.turn == TURN_JACKMOVE && availJackMoves.includes(nodeIndex)) {
            const label = toLetter(availJackMoves.indexOf(nodeIndex));
            drawText(label, {
                x: node.pos.x*scaleFactor - ctx.measureText(label).width/2,
                y: node.pos.y*scaleFactor - scaleFactor/5,
                fontSize: Math.floor(scaleFactor/3),
                font: "Arial",
                fillStyle: "orange",
                strokeStyle: "red",
                lineWidth: 2,
                bold: true
            });
        }

        // labels for starting nodes for detectives
        if (cs.turn == TURN_DET_START && node.starting) {
            const label = `${startingNodes.indexOf(nodeIndex)+1}`;
            drawText(label, {
                x: node.pos.x*scaleFactor - ctx.measureText(label).width/2,
                y: node.pos.y*scaleFactor - scaleFactor/5,
                fontSize: Math.floor(scaleFactor/3),
                font: "Arial",
                fillStyle: "orange",
                strokeStyle: "red",
                lineWidth: 2,
                bold: true
            });
        }

        // labels for options for checking for clues
        if (selectedDetective != null) {
            const alreadyChecked = cs.detectives[selectedDetective].checked.includes(nodeIndex);
            if (cs.turn == TURN_CLUES && clueOptions.includes(nodeIndex)) {
                const label = `${clueOptions.indexOf(nodeIndex)+1}`;
                drawText(label, {
                    x: node.pos.x*scaleFactor - ctx.measureText(label).width/2,
                    y: node.pos.y*scaleFactor - scaleFactor/5,
                    fontSize: Math.floor(scaleFactor/3),
                    font: "Arial",
                    fillStyle: alreadyChecked ? "gray" : "orange",
                    strokeStyle: alreadyChecked ? "gray" : "red",
                    lineWidth: 2,
                    bold: true
                });
            }
        }

        // label available detective moves
        if (selectedDetective != null) {
            if (cs.turn == TURN_DETMOVE && availDetMoves.includes(nodeIndex)) {
                const label = toLetter(availDetMoves.indexOf(nodeIndex));
                drawText(label, {
                    x: node.pos.x*scaleFactor - ctx.measureText(label).width/2,
                    y: node.pos.y*scaleFactor - scaleFactor/5,
                    fontSize: Math.floor(scaleFactor/3),
                    font: "Arial",
                    fillStyle: "orange",
                    strokeStyle: "red",
                    lineWidth: 2,
                    bold: true
                });
            }
        }
    }

    // jack move counter
    for (let i = 0; i < 16; i++) {
        ctx.beginPath();
        ctx.arc(
            (i*0.6 + 1.5)*scaleFactor,
            11.6*scaleFactor,
            0.13*scaleFactor,
            0, Math.PI*2
        );
        ctx.fillStyle = (i == 0) ? "red" : "white";
        ctx.fill();
        ctx.lineWidth   = (cs.jack.moves.length == i) ? 2 : 1;
        ctx.strokeStyle = (cs.jack.moves.length == i) ? "red" : "black";
        ctx.stroke();

        ctx.fillStyle = (i == 0) ? "yellow" : "black";
        ctx.font = `bold ${Math.floor(scaleFactor/6)}px Arial`;
        ctx.fillText(
            `${i}`,
            (i*0.6 + 1.5)*scaleFactor - ctx.measureText(`${i}`).width/2,
            11.65*scaleFactor
        );
    }

    if (editorMode) {
        drawText("<EDITOR MODE>", {fontSize: 50, y: 55});
    }

    let msg = "";
    if      (cs.turn == TURN_JACK_START)        { msg = "Jack: choose murder locations"; }
    else if (cs.turn == TURN_DET_START)         { msg = "Detectives: choose your starting locations"; }
    else if (cs.turn == TURN_FIRST_MURDER)      { msg = "Jack: choose your first murder location"; }
    else if (cs.turn == TURN_JACKMOVE)          { msg = "Jack: choose your next move"; }
    else if (cs.turn == TURN_DETMOVE)           { msg = "Detectives: choose your moves"; }
    else if (cs.turn == TURN_CLUES)             { msg = "Detectives: check for clues or make an arrest"; }
    else if (cs.turn == TURN_JACK_WINS)         { msg = "Jack wins!"; }
    else if (cs.turn == TURN_DETECTIVES_WIN)    { msg = "Detectives win!"; }

    drawText(msg, {
        fontSize: scaleFactor/3,
        y: height - scaleFactor/2,
        stroke: false,
        fillStyle: "black",
        bold: true
    });

    let msg2 = "";
    if (cs.turn == TURN_JACK_START && cs.chosenLocations.filter(loc => loc > 0).length == 4) {
        msg2 = "Press ENTER to continue";
    } else if (cs.turn == TURN_DET_START) {
        msg2 = "";
    } else if (cs.turn == TURN_FIRST_MURDER) {
        msg2 = "";
    } else if (cs.turn == TURN_JACKMOVE) {
        msg2 = "";
    } else if (cs.turn == TURN_DETMOVE) {
        msg2 = "";
    } else if (cs.turn == TURN_CLUES) {
        if      (cs.action == ACTION_NONE)      msg2 = "'A' to make an arrest, 'C' to check for clues";
        else if (cs.action == ACTION_CLUES)     msg2 = "Checking for clues ('A' to make an arrest)";
        else if (cs.action == ACTION_ARREST)    msg2 = "Making an arrest ('C' to check for clues)";
    } else if (cs.turn == TURN_JACK_WINS) {
        msg2 = "";
    } else if (cs.turn == TURN_DETECTIVES_WIN) {
        if (getMovesForJack().length == 0)
            msg2 = "Jack is trapped";
    }

    drawText(msg2, {
        fontSize: scaleFactor/3,
        y: height - scaleFactor/10,
        stroke: false,
        fillStyle: "black",
        bold: true
    });
}

function update(t, dt) {
    // update game state here
}

// TODO: avoid consuming processor
function loop(t) {
    let frameTime = t - prevTime;
    prevTime = t;

    if (frameTime > MAX_FRAMETIME) {
        //console.log(`frameTime > MAX_FRAMETIME : ${frameTime}`);
        frameTime = MAX_FRAMETIME;
    }

    accumulator += frameTime * simRate;

    while (accumulator >= fixed_dt) {
        update(t, fixed_dt);
        accumulator -= fixed_dt;
    }

    draw();
    //window.requestAnimationFrame(loop);
}

loop(0);

function blur(e) {
}

function focus(e) {
}

function resize(e) {
    width = canvas.width = window.innerWidth;
    height = canvas.height = window.innerHeight;
    scaleFactor = Math.floor(canvas.height/12.5);
    draw();
}

function keydown(e) {
    if (e.key === 'E') {
        editorMode = !editorMode;
    //} else if (e.key === ',' || e.key === '.') {
    //    if (e.key === ',')
    //        simRate /= 2;
    //    else if (e.key === '.')
    //        simRate *= 2;
    //    console.log(`simRate: ${simRate}`);
    } else if (e.key === 'R') {
        reset();
    } else if (e.key === '?') {
        console.log('TODO: help');
        validateGraph();
    }

    if (editorMode) {
        if (e.key === 'Escape') {
            editorMode = false;
        } else if (e.key === 'j' || e.key == 'd') {
            const newNodeIndex = newNode(e.key);
            actionStack.push({
                type: 'newNode',
                nodeType: e.key,
                pos: Object.assign({}, graph[newNodeIndex].pos),
                index: newNodeIndex
            });
            redoStack.length = 0;
        } else if (e.key === 'Delete') {
            const nodeIndex = getNodeNear(mouseX, mouseY);
            if (nodeIndex != null) {
                actionStack.push({
                    type: 'deleteNode',
                    nodeType: graph[nodeIndex].type,
                    pos: Object.assign({}, graph[nodeIndex].pos),
                    index: nodeIndex,
                    neighbors: [...graph[nodeIndex].neighbors]
                });
                redoStack.length = 0;
                deleteNode(nodeIndex);
            }
        } else if (e.key === 'u') {
            undo();
        } else if (e.key === 'r') {
            redo();
        }
    } else {
        if (e.key === 'S') {
            saveState();
        } else if (e.key === 'L') {
            restoreState();
        }

        if (cs.turn == TURN_JACK_START) {
            // TODO: easy, medium, hard
            if (e.key == 'r') {
                cs.chosenLocations = [];
                for (let i = 1; i <= 4; i++) {
                    let r = 0;
                    while (graph[r].quadrant != i || graph[r].boat || cs.chosenLocations.includes(r)) {
                        r = Math.floor(Math.random()*189);
                    }
                    cs.chosenLocations.push(r);
                }
            } else if (e.key == 'Enter') {
                if (cs.chosenLocations.filter(loc => loc > 0).length == 4) {
                    cs.turn = TURN_DET_START;
                    selectedDetective = 0; // XXX
                }
            }
        } else if (cs.turn == TURN_DET_START) {
            if (e.key >= '1' && e.key <= '9') {
                const startingNodes = graph.map((n, index) => { return {index: index, n: n}; }).filter(e => e.n.starting).map(e => e.index);
                if (e.key <= startingNodes.length) {
                    const choice = startingNodes[e.key-1];
                    if (!cs.detectives.map(d => d.location).includes(choice))
                        chooseStartingLocation(choice);
                }
            }
        } else if (cs.turn == TURN_FIRST_MURDER) {
            if (e.key >= '1' && e.key <= '9') {
                if (e.key <= cs.chosenLocations.length) {
                    cs.murders.push(cs.chosenLocations[e.key-1]);
                    cs.jack.location = cs.chosenLocations[e.key-1];
                    cs.turn = TURN_JACKMOVE;
                }
            }
        } else if (cs.turn == TURN_JACKMOVE) {
            const availMoves = getMovesForJack();
            if (isAtoZ(e.key) && ord(e.key) < availMoves.length) {
                const move = availMoves[ord(e.key)];
                cs.jack.location = move;
                cs.jack.moves.push(move);
                cs.turn = TURN_DETMOVE;
                selectedDetective = 0; // XXX
            }
        } else if (cs.turn == TURN_DETMOVE) {

            //if (e.key === 'y') {
            //    selectedDetective = (selectedDetective == 0) ? null : 0;
            //} if (e.key === 'b') {
            //    selectedDetective = (selectedDetective == 1) ? null : 1;
            //} else if (e.key === 'r') {
            //    selectedDetective = (selectedDetective == 2) ? null : 2;
            //}

            if (e.key === 'Escape') {
                selectedDetective = null;
            }
            if (isAtoZ(e.key)) {
                if (selectedDetective != null) {
                    const availMoves = getMovesForDetective(selectedDetective);
                    if (ord(e.key) < availMoves.length) {
                        const move = availMoves[ord(e.key)];
                        cs.detectives[selectedDetective].location = move;
                        cs.detectives[selectedDetective].moved = true;
                        //selectedDetective = null; // XXX
                        selectedDetective++;
                        if (selectedDetective > 2)
                            selectedDetective = null;
                    }
                }
            }
            if (cs.detectives.every(d => d.moved)) {
                cs.turn = TURN_CLUES;
                cs.action = ACTION_CLUES;
                selectedDetective = 0;
            }
        } else if (cs.turn == TURN_CLUES) {
            if (e.key == 'A' && cs.detectives[selectedDetective].checked.length == 0) {
                cs.action = ACTION_ARREST;
            } else if (e.key == 'C') {
                cs.action = ACTION_CLUES;
            }
            if (e.key >= '1' && e.key <= '9') {
                const clueOptions = getClueOptions(selectedDetective);
                if (e.key <= clueOptions.length) {
                    const choice = clueOptions[e.key-1];
                    if (cs.action == ACTION_CLUES) {
                        chooseClue(choice);
                    } else if (cs.action == ACTION_ARREST) {
                        arrestOn(choice);
                    }
                }
            }
        }
    }

    if (editorMode) {
        selectedDetective = null;
    } else {
        clickedNodeIndex = null;
        rightClickedNodeIndex = null;
    }

    draw();
}

function getNodeNear(x, y, radius = 0.14) {
    for (const [nodeIndex, jackNode] of graph.entries()) {
        const dx = x - jackNode.pos.x*scaleFactor;
        const dy = y - jackNode.pos.y*scaleFactor;
        // TODO: base radius off node type
        if (Math.sqrt(dx*dx + dy*dy) < radius*scaleFactor) {
            return nodeIndex;
        }
    }
    return null;
}

function mousedown(e) {
    if (editorMode) {
        if (e.button == LEFT_BUTTON) {
            if (rightClickedNodeIndex == null) {
                clickedNodeIndex = getNodeNear(e.clientX, e.clientY);
                if (clickedNodeIndex != null) {
                    clickedNodeOriginalPos = Object.assign({}, graph[clickedNodeIndex].pos);
                }
            } else {
                let dstIndex = getNodeNear(e.clientX, e.clientY);
                if (dstIndex == null) {
                    rightClickedNodeIndex = null;
                } else {
                    if (graph[rightClickedNodeIndex].type == 'j' && graph[dstIndex].type == 'j') {
                        console.log('cannot connect two jack nodes directly');
                    } else if (rightClickedNodeIndex == dstIndex) {
                        console.log('cannot connect a node to itself');
                    } else {
                        if (!graph[rightClickedNodeIndex].neighbors.includes(dstIndex)) {
                            actionStack.push({type: 'connect', src: rightClickedNodeIndex, dst: dstIndex});
                            redoStack.length = 0;
                            connectNodes(rightClickedNodeIndex, dstIndex);
                        } else {
                            actionStack.push({type: 'disconnect', src: rightClickedNodeIndex, dst: dstIndex});
                            redoStack.length = 0;
                            disconnectNodes(rightClickedNodeIndex, dstIndex);
                        }
                        rightClickedNodeIndex = null;
                    }
                }
            }
        } else if (e.button == RIGHT_BUTTON) {
            rightClickedNodeIndex = getNodeNear(e.clientX, e.clientY);
        }
    } else {
        if (cs.turn == TURN_JACK_START) {
            const chosen = getNodeNear(mouseX, mouseY);
            if (chosen != null              && 
                graph[chosen].type == 'j'   &&
                graph[chosen].quadrant != 0 &&
                !graph[chosen].boat) {
                cs.chosenLocations[graph[chosen].quadrant-1] = chosen;
            }
        } else if (cs.turn == TURN_DET_START) {
            const nodeIndex = getNodeNear(mouseX, mouseY);
            if (nodeIndex != null && graph[nodeIndex].type == 'd' && graph[nodeIndex].starting) {
                chooseStartingLocation(nodeIndex);
            }
        } else if (cs.turn == TURN_FIRST_MURDER) {
            const nodeIndex = getNodeNear(mouseX, mouseY);
            if (nodeIndex != null) {
                if (cs.chosenLocations.includes(nodeIndex)) {
                    cs.murders.push(nodeIndex);
                    cs.jack.location = nodeIndex;
                    cs.turn = TURN_JACKMOVE;
                }
            }
        } else if (cs.turn == TURN_JACKMOVE) {
            const availMoves = getMovesForJack();
            const nodeIndex = getNodeNear(mouseX, mouseY);
            if (nodeIndex != null) {
                if (availMoves.includes(nodeIndex)) {
                    cs.jack.location = nodeIndex;
                    cs.jack.moves.push(nodeIndex);
                    cs.turn = TURN_DETMOVE;
                    selectedDetective = 0; // XXX
                }
            }
        } else if (cs.turn == TURN_DETMOVE) {
            const nodeIndex = getNodeNear(mouseX, mouseY);
            if (nodeIndex != null) {
                if (selectedDetective == null) {
                    cs.detectives.forEach((d, di) => { if (d.location == nodeIndex) selectedDetective = di; });
                } else {
                    const availMoves = getMovesForDetective(selectedDetective);
                    if (availMoves.includes(nodeIndex)) {
                        cs.detectives[selectedDetective].location = nodeIndex;
                        cs.detectives[selectedDetective].moved = true;
                        //selectedDetective = null;
                        selectedDetective++;
                        if (selectedDetective > 2)
                            selectedDetective = null;
                    }
                }
            }
            if (cs.detectives.every(d => d.moved)) {
                cs.turn = TURN_CLUES;
                cs.action = ACTION_CLUES;
                selectedDetective = 0;
            }
        } else if (cs.turn == TURN_CLUES) {
            const clueOptions = getClueOptions(selectedDetective);
            const choice = getNodeNear(mouseX, mouseY);
            if (clueOptions.includes(choice)) {
                if (cs.action == ACTION_CLUES)
                    chooseClue(choice);
                else if (cs.action == ACTION_ARREST)
                    arrestOn(choice);
            }
        } else if (cs.turn == TURN_JACK_WINS) {
        } else if (cs.turn == TURN_DETECTIVES_WIN) {
        }
    }
    draw();
}

function mouseup(e) {
    if (e.button == LEFT_BUTTON) {
        if (clickedNodeIndex) {
            actionStack.push({type: 'move', nodeIndex: clickedNodeIndex, from: Object.assign({}, clickedNodeOriginalPos), to: Object.assign({}, graph[clickedNodeIndex].pos)});
            redoStack.length = 0;
            clickedNodeIndex = null;
        }
    }
    draw();
}

function mousemove(e) {
    if (editorMode) {
        if (clickedNodeIndex) {
            graph[clickedNodeIndex].pos.x = round(e.clientX / scaleFactor, 1);
            graph[clickedNodeIndex].pos.y = round(e.clientY / scaleFactor, 1);
        }
    }
    mouseX = e.clientX;
    mouseY = e.clientY;
    draw();
}

window.addEventListener('blur', blur);
window.addEventListener('focus', focus);
window.addEventListener('keydown', keydown);
window.addEventListener('resize', resize);
window.addEventListener('mousedown', mousedown);
window.addEventListener('mouseup', mouseup);
window.addEventListener('mousemove', mousemove);
window.addEventListener('contextmenu', event => event.preventDefault());

        </script>
    </body>

</html>
