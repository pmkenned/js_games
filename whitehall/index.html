<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8">
        <meta name ="viewport" content="width=device-width, initial-scale=1.0">
        <title>Whitehall</title>
<style>
body {
    margin: 0;
    overflow: hidden;
}
</style>
    </head>

    <body>
        <canvas id="myCanvas"></canvas>

        <script src="graph.js"></script>
        <script>
// TODO: reorder nodes feature
// TODO: neighbors array should be Set()
// TODO: allow for making arrests

const detectiveColors = [
    { normal: "hsl(60,    80%, 60%)", selected: "hsl(60,    80%, 80%)"  },
    { normal: "hsl(240,   80%, 60%)", selected: "hsl(240,   80%, 80%)"  },
    { normal: "hsl(0,     80%, 60%)", selected: "hsl(0,     80%, 80%)"  },
];

const actionStack = [];
const redoStack = [];

const errorNodes = new Set();

const canvas = document.getElementById('myCanvas');
const ctx = canvas.getContext('2d');

let scaleFactor = 80; // TODO: based on window dimensions

const fixed_dt = 8; // 125 Hz
const MAX_FRAMETIME = 250;

const LEFT_BUTTON   = 0;
const RIGHT_BUTTON  = 2;

const TURN_CHOOSE_LOCATIONS = 0;
const TURN_FIRST_MURDER     = 1;
const TURN_JACKMOVE         = 2;
const TURN_DETMOVE          = 3;
const TURN_CLUES            = 4;
const TURN_JACK_WINS        = 5;
const TURN_DETECTIVES_WIN   = 6;

const ACTION_CLUES  = 0;
const ACTION_ARREST = 1;

let editorMode = false;
let clickedNodeIndex = null;
let clickedNodeOriginalPos;
let rightClickedNodeIndex = null;
let mouseX = 0;
let mouseY = 0;

let width;
let height;
let accumulator;
let simRate;
let prevTime;

let selectedDetective = null;

let cs = {};
let ss = {};

let inputsToSim = {
    // 160 : [ { key: 'ArrowDown',   mode: 'down'   }, ],
};

function saveState() {
    ss = JSON.parse(JSON.stringify(cs));
}

function restoreState() {
    cs = JSON.parse(JSON.stringify(ss));
}

function makeGraphConsistent() {
    // if A->B then B->A
    for (const [nodeIndex, node] of graph.entries()) {
        for (const neighborIndex of node.neighbors) {
            const neighborNode = graph[neighborIndex];
            if (!neighborNode.neighbors.includes(nodeIndex)) {
                neighborNode.neighbors.push(nodeIndex);
            }
        }
    }
}

function validateGraph() {

    errorNodes.clear();

    let returnValue = true;

    // if A->B then B->A
    for (const [nodeIndex, node] of graph.entries()) {
        for (const neighborIndex of node.neighbors) {
            const neighborNode = graph[neighborIndex];
            if (!neighborNode.neighbors.includes(nodeIndex)) {
                console.error(`${nodeIndex}->${neighborIndex} but not ${neighborIndex}->${nodeIndex}`);
                errorNodes.add(nodeIndex);
                errorNodes.add(neighborIndex);
                returnValue = false;
            }
        }
    }

    // no A->A
    for (const [nodeIndex, node] of graph.entries()) {
        if (node.neighbors.includes(nodeIndex)) {
            console.error(`${nodeIndex}->${nodeIndex}`);
            errorNodes.add(nodeIndex);
            returnValue = false;
        }
    }

    // no Jack->Jack
    for (const [nodeIndex, node] of graph.entries()) {
        if (node.type != 'j')
            continue;
        for (const neighborIndex of node.neighbors) {
            const neighborNode = graph[neighborIndex];
            if (neighborNode.type == 'j') {
                console.error(`Jack->Jack: ${nodeIndex}->${neighborIndex}`);
                errorNodes.add(nodeIndex);
                errorNodes.add(neighborIndex);
                returnValue = false;
            }
        }
    }

    // no repeated neighbors
    for (const [nodeIndex, node] of graph.entries()) {
        if (hasDuplicates(node.neighbors)) {
            console.error(`node ${nodeIndex} has duplicate neighbors: ${node.neighbors}`);
            errorNodes.add(nodeIndex);
            returnValue = false;
        }
    }

    // no nodes with zero neighbors
    for (const [nodeIndex, node] of graph.entries()) {
        if (nodeIndex == 0)
            continue;
        if (node.neighbors.length == 0) {
            console.error(`${nodeIndex} has zero neighbors`);
            errorNodes.add(nodeIndex);
            returnValue = false;
        }
    }

    // no non-boat Jack nodes with fewer than 2 neighbors
    for (const [nodeIndex, node] of graph.entries()) {
        if (node.type != 'j' || node.boat)
            continue;
        if (node.neighbors.length < 2) {
            console.error(`non-boat Jack node ${nodeIndex} has fewer than 2 neighbors`);
            errorNodes.add(nodeIndex);
            returnValue = false;
        }
    }

    // no detective nodes with fewer than 2 neighbors
    for (const [nodeIndex, node] of graph.entries()) {
        if (node.type != 'd')
            continue;
        if (node.neighbors.length < 2) {
            console.error(`detective node ${nodeIndex} has fewer than 2 neighbors`);
            errorNodes.add(nodeIndex);
            returnValue = false;
        }
    }

    return returnValue;
}

function reset() {
    accumulator = 0;
    simRate = 1.0;
    prevTime = 0;

    cs =  {
        turn: TURN_FIRST_MURDER,
        round: 0,
        chosenLocations: [32, 46, 147, 120],
        jack: {
            moves: [],
            location: null
        },
        detectives: [
            { location: 275, moved: false, acted: false, checked: [] },
            { location: 298, moved: false, acted: false, checked: [] },
            { location: 279, moved: false, acted: false, checked: [] },
        ],
        action: ACTION_CLUES,
        clues: [],
        murders: []
    };
    saveState();

    //makeGraphConsistent();
    if (!validateGraph()) {
        console.error('invalid graph');
    }

    resize();
}

reset();

function newNode(type, x, y, index) {

    // default to current mouse position
    x ??= round(mouseX/scaleFactor, 1);
    y ??= round(mouseY/scaleFactor, 1);

    // default insertion index
    if (type == 'j') {
        const indexOfLastJackNode = graph.filter(x => x.type == 'j').length;
        index ??= indexOfLastJackNode+1;
    } else if (type == 'd') {
        index ??= graph.length;
    }

    // adjust neighbor indices for existing nodes
    for (const node of graph) {
        node.neighbors.forEach((item, itemIndex, arr) => {
            if (item >= index) {
                arr[itemIndex]++;
            }
        });
    }

    // insert new node
    if (type == 'j') {
        graph.splice(index, 0, { "type": "j", "pos": { "x": x, "y": y }, "quadrant": 0, "neighbors": [ ], "boat": false });
    } else if (type == 'd') {
        graph.splice(index, 0, { "type": "d", "pos": { "x": x, "y": y }, "starting": false, "neighbors": [ ] });
    }

    return index;
}

function connectNodes(a, b) {
    graph[a].neighbors.push(b);
    graph[b].neighbors.push(a);
}

function disconnectNodes(a, b) {
    removeItemOnce(graph[a].neighbors, b);
    removeItemOnce(graph[b].neighbors, a);
}

function deleteNode(nodeIndex) {
    const toDisonnect = [...graph[nodeIndex].neighbors];
    toDisonnect.forEach(neighborIndex => disconnectNodes(nodeIndex, neighborIndex));
    for (const node of graph) {
        node.neighbors.forEach((item, index, arr) => {
            if (item > nodeIndex) {
                arr[index]--;
            }
        });
    }
    graph.splice(nodeIndex, 1);
}

function undo() {
    if (actionStack.length == 0)
        return;
    const action = actionStack.pop();
    if (action.type == 'move') {
        Object.assign(graph[action.nodeIndex].pos, action.from);
    } else if (action.type == 'connect') {
        disconnectNodes(action.src, action.dst);
    } else if (action.type == 'disconnect') {
        connectNodes(action.src, action.dst);
    } else if (action.type == 'newNode') {
        deleteNode(action.index);
    } else if (action.type == 'deleteNode') {
        newNode(action.nodeType, action.pos.x, action.pos.y, action.index);
        action.neighbors.forEach(neighborIndex => connectNodes(action.index, neighborIndex));
    }
    redoStack.push(action);
}

function redo() {
    if (redoStack.length == 0)
        return;
    const action = redoStack.pop();
    if (action.type == 'move') {
        Object.assign(graph[action.nodeIndex].pos, action.to);
    } else if (action.type == 'connect') {
        connectNodes(action.src, action.dst);
    } else if (action.type == 'disconnect') {
        disconnectNodes(action.src, action.dst);
    } else if (action.type == 'newNode') {
        newNode(action.nodeType, action.pos.x, action.pos.y);
    } else if (action.type == 'deleteNode') {
        deleteNode(action.index);
    }
    actionStack.push(action);
}

function px(x, f=0.0) { return Math.round(x) + f; }

function removeItemOnce(arr, value) {
    const index = arr.indexOf(value);
    if (index > -1) {
        arr.splice(index, 1);
    }
    return arr;
}

function hasDuplicates(array) {
    return (new Set(array)).size !== array.length;
}

function round(value, precision) {
    const multiplier = Math.pow(10, precision || 0);
    return Math.round(value * multiplier) / multiplier;
}

function drawRect(sr)
{
    ctx.fillRect(px(sr.x - sr.w/2), px(sr.y - sr.h/2), sr.w, sr.h);
}

function drawText(text, params) {
    params              ??= {}
    params.fontSize     ??= 40;
    params.font         ??= "Calibri";
    params.lineWidth    ??= 2;
    params.fillStyle    ??= "white";
    params.strokeStyle  ??= "black";
    params.fill         ??= true;
    params.stroke       ??= true;
    params.bold         ??= false;
    ctx.font        = (params.bold ? "bold " : "") + `${params.fontSize}px ${params.font}`;
    ctx.lineWidth   = params.lineWidth;
    ctx.fillStyle   = params.fillStyle;
    ctx.strokeStyle = params.strokeStyle;
    params.x            ??= width/2 - ctx.measureText(text).width/2;
    params.y            ??= height/2 + params.fontSize/3;
    if (params.fill)
        ctx.fillText(text, params.x, params.y);
    if (params.stroke)
        ctx.strokeText(text, params.x, params.y);
}

function jackNodesWithinN(location, n) {
    const withinN = new Set();
    if (n <= 0)
        return [];
    const queue = [];
    // TODO: BFS
    //graph[cs.jack.location].neighbors.forEach(ni => queue.push(ni));
    for (const neighborIndex of graph[location].neighbors) {
    }
    withinN.add(53);
    withinN.add(13);
    withinN.delete(location);
    return Array.from(withinN);
}

function detNodesWithinN(location, n) {
    const withinN = new Set();
    if (n <= 0)
        return [];
    for (const neighborIndex of graph[location].neighbors) {
        if (graph[neighborIndex].type == 'd') {
            withinN.add(neighborIndex);
            detNodesWithinN(neighborIndex, n-1).forEach(item => withinN.add(item));
        } else if (graph[neighborIndex].type == 'j') {
            for (const neighborIndex2 of graph[neighborIndex].neighbors) {
                withinN.add(neighborIndex2);
                detNodesWithinN(neighborIndex2, n-1).forEach(item => withinN.add(item));
            }
        }
    }
    return Array.from(withinN);
}

function draw() {
    ctx.clearRect(0, 0, width, height);

    ctx.fillStyle = "hsl(28, 60%, 75%)";
    ctx.fillRect(0, 0, width, height);

    // draw grid
    ctx.lineWidth = 1;
    ctx.strokeStyle = "hsl(0, 0%, 50%)";
    for (let c = 0; c < 12; c++) {
        ctx.beginPath();
        ctx.moveTo(px(c*scaleFactor, 0.5), 0);
        ctx.lineTo(px(c*scaleFactor, 0.5), 12*scaleFactor);
        ctx.stroke();
    }
    for (let r = 0; r < 12; r++) {
        ctx.beginPath();
        ctx.moveTo(0,               px(r*scaleFactor, 0.5));
        ctx.lineTo(12*scaleFactor,  px(r*scaleFactor, 0.5));
        ctx.stroke();
    }

    const hoverNodeIdx = getNodeNear(mouseX, mouseY);

    const cluesOptions = (selectedDetective != null && !cs.detectives[selectedDetective].acted) ?
        graph[cs.detectives[selectedDetective].location].neighbors.filter(n => graph[n].type == 'j'):
        [];
    const availMoves = (selectedDetective != null && !cs.detectives[selectedDetective].moved) ?
        detNodesWithinN(cs.detectives[selectedDetective].location, 2) :
        [];

    // draw Jack Graph
    ctx.lineWidth = 2;
    for (const [nodeIndex, jackNode] of graph.entries()) {
        if (jackNode.type != 'j')
            continue;
        // skip dummy node
        if (nodeIndex == 0)
            continue;

        // === BEGIN FOR DEBUG ===
        if ((jackNode.pos.x == 0) && (jackNode.pos.y == 0)) {
            jackNode.pos.x = 1 + ((nodeIndex-8) % 20) * 0.5;
            jackNode.pos.y = 5 + Math.floor((nodeIndex-8) / 20) * 0.5;
        }
        // === END   FOR DEBUG ===

        // draw lines to detective nodes
        ctx.lineWidth = 2;
        ctx.strokeStyle = "black";
        ctx.setLineDash([5, 5]);
        for (const detNodeIndex of jackNode.neighbors) {
            const detNode = graph[detNodeIndex];
            if (detNode === undefined) {
                continue;
            }
            ctx.beginPath();
            ctx.moveTo(
                jackNode.pos.x*scaleFactor,
                jackNode.pos.y*scaleFactor,
            );
            ctx.lineTo(detNode.pos.x*scaleFactor, detNode.pos.y*scaleFactor);
            ctx.stroke();
        }
        ctx.setLineDash([]);

        // circle
        ctx.strokeStyle = "black";
        ctx.fillStyle = jackNode.quadrant == 0 ? "black" : "white";
        if (jackNode.boat) ctx.fillStyle = "skyblue";
        // === BEGIN FOR DEBUG ===
        //if (jackNode.quadrant == 1)         { ctx.fillStyle = "red"; }
        //else if (jackNode.quadrant == 2)    { ctx.fillStyle = "green"; }
        //else if (jackNode.quadrant == 3)    { ctx.fillStyle = "blue"; }
        //else if (jackNode.quadrant == 4)    { ctx.fillStyle = "purple"; }
        if (hoverNodeIdx == nodeIndex) ctx.fillStyle = "orange";
        if (errorNodes.has(nodeIndex)) ctx.fillStyle = "red";
        // === END  FOR DEBUG ===
        ctx.beginPath();
        ctx.arc(
            jackNode.pos.x*scaleFactor,
            jackNode.pos.y*scaleFactor,
            0.14*scaleFactor,
            0, Math.PI*2
        );
        ctx.stroke();
        ctx.fill();

        // show jack's current location
        if (cs.turn == TURN_JACKMOVE && cs.jack.location == nodeIndex) {
            ctx.fillStyle = "green";
            ctx.fill();
        }

        // show options for checking for clues
        if (selectedDetective != null) {
            const alreadyChecked = cs.detectives[selectedDetective].checked.includes(nodeIndex);
            if (cs.turn == TURN_CLUES && cluesOptions.includes(nodeIndex)) {
                ctx.lineWidth = 2;
                ctx.strokeStyle = "red";
                if (!alreadyChecked)
                    ctx.stroke();
                const label = `${cluesOptions.indexOf(nodeIndex)+1}`;
                drawText(label, {
                    x: jackNode.pos.x*scaleFactor - ctx.measureText(label).width/2,
                    y: jackNode.pos.y*scaleFactor - scaleFactor/5,
                    fontSize: Math.floor(scaleFactor/3),
                    font: "Arial",
                    fillStyle: alreadyChecked ? "gray" : "orange",
                    strokeStyle: alreadyChecked ? "gray" : "red",
                    lineWidth: 2,
                    bold: true
                });
            }
        }

        // clues
        // TODO: indicate how many clues are on a location
        if (cs.clues.includes(nodeIndex)) {
            ctx.fillStyle = "hsla(60, 80%, 50%, 0.7)";
            ctx.fill();
        }

        // chosen locations
        if (cs.turn == TURN_CHOOSE_LOCATIONS || cs.turn == TURN_FIRST_MURDER) {
            if (cs.chosenLocations.includes(nodeIndex)) {
                ctx.fillStyle = "hsla(0, 80%, 50%, 0.7)";
                ctx.fill();
            }
        }

        // murders
        if (cs.murders.includes(nodeIndex)) {
            ctx.fillStyle = "hsla(0, 80%, 50%, 0.7)";
            ctx.fill();
        }

        // node label
        ctx.fillStyle = jackNode.quadrant == 0 ? "white" : "black";
        ctx.font = `bold ${Math.floor(scaleFactor/6)}px Arial`;
        ctx.fillText(
            `${nodeIndex}`,
            jackNode.pos.x*scaleFactor - ctx.measureText(`${nodeIndex}`).width/2,
            jackNode.pos.y*scaleFactor + scaleFactor/20
        );
    }

    // draw detective graph
    for (const [detNodeIndex, detNode] of graph.entries()) {
        if (detNode.type != 'd')
            continue;
        // === BEGIN FOR DEBUG ===
        if ((detNode.pos.x == 0) && (detNode.pos.y == 0)) {
            detNode.pos.x = 1 + ((detNodeIndex-189) % 20) * 0.5;
            detNode.pos.y = 8.5 + Math.floor((detNodeIndex-189) / 20) * 0.5;
        }
        // === END   FOR DEBUG ===
        // draw lines to detective nodes
        ctx.lineWidth = 2;
        ctx.strokeStyle = "black";
        ctx.setLineDash([5, 5]);
        for (const neighborIndex of detNode.neighbors) {
            if (neighborIndex < detNodeIndex)
                continue; // draw only one line (A->B, skip B->A)
            const detNode2 = graph[neighborIndex];
            if (detNode2 === undefined) {
                continue;
            }
            ctx.beginPath();
            ctx.moveTo(
                detNode.pos.x*scaleFactor,
                detNode.pos.y*scaleFactor,
            );
            ctx.lineTo(detNode2.pos.x*scaleFactor, detNode2.pos.y*scaleFactor);
            ctx.stroke();
        }
        ctx.setLineDash([]);

        // square
        ctx.lineWidth = 6;
        ctx.strokeStyle =  "gold";
        ctx.fillStyle = "black";
        if (hoverNodeIdx == detNodeIndex) ctx.fillStyle = "orange";
        if (errorNodes.has(detNodeIndex)) ctx.fillStyle = "red";
        ctx.beginPath();
        ctx.rect(
            detNode.pos.x*scaleFactor - scaleFactor/20,
            detNode.pos.y*scaleFactor - scaleFactor/20,
            scaleFactor/10,
            scaleFactor/10
        );
        if (detNode.starting)
            ctx.stroke();
        ctx.fill();

        // TODO: draw these above everything
        if (selectedDetective != null) {
            if (cs.turn == TURN_DETMOVE && availMoves.includes(detNodeIndex)) {
                ctx.strokeStyle = "white";
                ctx.stroke();
                ctx.fill();
                const label = `${availMoves.indexOf(detNodeIndex)+1}`;
                drawText(label, {
                    x: detNode.pos.x*scaleFactor - ctx.measureText(label).width/2,
                    y: detNode.pos.y*scaleFactor - scaleFactor/5,
                    fontSize: Math.floor(scaleFactor/3),
                    font: "Arial",
                    fillStyle: "orange",
                    strokeStyle: "red",
                    lineWidth: 2,
                    bold: true
                });
            }
        }

        // === BEGIN FOR DEBUG ===
        // node label
        if (editorMode && hoverNodeIdx == detNodeIndex) {
            ctx.fillStyle = "red";
            ctx.font = `bold ${Math.floor(scaleFactor/6)}px Arial`;
            ctx.fillText(
                `${detNodeIndex-0}`,
                detNode.pos.x*scaleFactor - scaleFactor/20,
                detNode.pos.y*scaleFactor - scaleFactor/10
            );
        }
        // === END   FOR DEBUG ===
    }

    // draw new line from right-click
    if (rightClickedNodeIndex) {
        ctx.lineWidth = 2;
        ctx.strokeStyle = "black";
        ctx.setLineDash([5, 5]);
        ctx.beginPath();
        ctx.moveTo(
            graph[rightClickedNodeIndex].pos.x*scaleFactor,
            graph[rightClickedNodeIndex].pos.y*scaleFactor,
        );
        ctx.lineTo(mouseX, mouseY);
        ctx.stroke();
        ctx.setLineDash([]);
    }

    // detectives
    ctx.lineWidth = 2;
    for (const [detNum, detective] of cs.detectives.entries()) {
        if (detective.location === null)
            continue;
        const detPos = graph[detective.location].pos;
        ctx.beginPath();
        ctx.rect(
            detPos.x*scaleFactor - scaleFactor/8,
            detPos.y*scaleFactor - scaleFactor/8,
            scaleFactor/4,
            scaleFactor/4
        );
        ctx.fillStyle   = (selectedDetective == detNum) ? detectiveColors[detNum].selected : detectiveColors[detNum].normal;
        ctx.strokeStyle = (selectedDetective == detNum) ? "white" : "black";
        ctx.fill();
        ctx.stroke();
    }

    // jack
    for (let i = 0; i < 16; i++) {
        ctx.beginPath();
        ctx.arc(
            (i*0.6 + 1.5)*scaleFactor,
            11.6*scaleFactor,
            0.13*scaleFactor,
            0, Math.PI*2
        );
        ctx.fillStyle = (i == 0) ? "red" : "white";
        ctx.fill();
        ctx.lineWidth   = (cs.jack.moves.length == i) ? 2 : 1;
        ctx.strokeStyle = (cs.jack.moves.length == i) ? "red" : "black";
        ctx.stroke();

        ctx.fillStyle = (i == 0) ? "yellow" : "black";
        ctx.font = `bold ${Math.floor(scaleFactor/6)}px Arial`;
        ctx.fillText(
            `${i}`,
            (i*0.6 + 1.5)*scaleFactor - ctx.measureText(`${i}`).width/2,
            11.65*scaleFactor
        );
    }

    if (editorMode) {
        drawText("<EDITOR MODE>", {fontSize: 50, y: 55});
    }

    let msg = "";
    if      (cs.turn == TURN_CHOOSE_LOCATIONS)  { msg = "Jack: choose murder locations"; }
    else if (cs.turn == TURN_FIRST_MURDER)      { msg = "Jack: choose your first murder location"; }
    else if (cs.turn == TURN_JACKMOVE)          { msg = "Jack: choose your next move"; }
    else if (cs.turn == TURN_DETMOVE)           { msg = "Detectives: choose your moves"; }
    else if (cs.turn == TURN_CLUES)             { msg = "Detectives: check for clues or make an arrest"; }
    else if (cs.turn == TURN_JACK_WINS)         { msg = "Jack wins!"; }
    else if (cs.turn == TURN_DETECTIVES_WIN)    { msg = "Detectives win!"; }

    drawText(msg, {
        fontSize: 25,
        y: height-8,
        stroke: false,
        fillStyle: "black",
        bold: true
    });
}

function update(t, dt) {
    // update game state here
}

// TODO: avoid consuming processor
function loop(t) {
    let frameTime = t - prevTime;
    prevTime = t;

    if (frameTime > MAX_FRAMETIME) {
        //console.log(`frameTime > MAX_FRAMETIME : ${frameTime}`);
        frameTime = MAX_FRAMETIME;
    }

    accumulator += frameTime * simRate;

    while (accumulator >= fixed_dt) {
        update(t, fixed_dt);
        accumulator -= fixed_dt;
    }

    draw();
    //window.requestAnimationFrame(loop);
}

loop(0);

function blur(e) {
}

function focus(e) {
}

function resize(e) {
    width = canvas.width = window.innerWidth;
    height = canvas.height = window.innerHeight;
    scaleFactor = Math.floor(canvas.height/12);
    draw();
}

function keydown(e) {
    if (e.key === 'e') {
        editorMode = !editorMode;
    //} else if (e.key === ',' || e.key === '.') {
    //    if (e.key === ',')
    //        simRate /= 2;
    //    else if (e.key === '.')
    //        simRate *= 2;
    //    console.log(`simRate: ${simRate}`);
    } else if (e.key === 'R') {
        reset();
    } else if (e.key === '?') {
        console.log('TODO: help');
        validateGraph();
    }

    if (editorMode) {
        if (e.key === 'Escape') {
            editorMode = false;
        } else if (e.key === 'j' || e.key == 'd') {
            const newNodeIndex = newNode(e.key);
            actionStack.push({
                type: 'newNode',
                nodeType: e.key,
                pos: Object.assign({}, graph[newNodeIndex].pos),
                index: newNodeIndex
            });
            redoStack.length = 0;
        } else if (e.key === 'Delete') {
            const nodeIndex = getNodeNear(mouseX, mouseY);
            if (nodeIndex) {
                actionStack.push({
                    type: 'deleteNode',
                    nodeType: graph[nodeIndex].type,
                    pos: Object.assign({}, graph[nodeIndex].pos),
                    index: nodeIndex,
                    neighbors: [...graph[nodeIndex].neighbors]
                });
                redoStack.length = 0;
                deleteNode(nodeIndex);
            }
        } else if (e.key === 'u') {
            undo();
        } else if (e.key === 'r') {
            redo();
        }
    } else {
        if (e.key === 's') {
            saveState();
        } else if (e.key === 'l') {
            restoreState();
        }

        if (cs.turn == TURN_DETMOVE) {
            if (e.key === 'y') {
                selectedDetective = (selectedDetective == 0) ? null : 0;
            } if (e.key === 'b') {
                selectedDetective = (selectedDetective == 1) ? null : 1;
            } else if (e.key === 'r') {
                selectedDetective = (selectedDetective == 2) ? null : 2;
            }
        }

        if (cs.turn == TURN_DETMOVE) {
            if (e.key >= '1' && e.key <= '9') {
                // TODO: allow for selecting moves above 9
                if (selectedDetective != null) {
                    const availMoves = (!cs.detectives[selectedDetective].moved) ?
                        detNodesWithinN(cs.detectives[selectedDetective].location, 2) :
                        [];
                    if (e.key <= availMoves.length) {
                        cs.detectives[selectedDetective].location = availMoves[e.key-1];
                        cs.detectives[selectedDetective].moved = true;
                        selectedDetective = null;
                    }
                }
            }
            if (cs.detectives.every(d => d.moved)) {
                cs.turn = TURN_CLUES;
                cs.action = ACTION_CLUES;
                selectedDetective = 0;
            }
        } else if (cs.turn == TURN_CLUES) {
            // TODO
            if (e.key == 'a') {
                cs.action = ACTION_ARREST;
            } else if (e.key == 'c') {
                cs.action = ACTION_CLUES;
            }

            if (e.key >= '1' && e.key <= '9') {
                if (selectedDetective != null) {
                    const cluesOptions = (!cs.detectives[selectedDetective].acted) ?
                        graph[cs.detectives[selectedDetective].location].neighbors.filter(n => graph[n].type == 'j'):
                        [];
                    if (e.key <= cluesOptions.length) {
                        if (cs.jack.moves.includes(cluesOptions[e.key-1])) {
                            cs.clues.push(cluesOptions[e.key-1]);
                            cs.detectives[selectedDetective].acted = true;
                        } else {
                            cs.detectives[selectedDetective].checked.push(cluesOptions[e.key-1]);
                            if (cs.detectives[selectedDetective].checked.length == cluesOptions.length) {
                                cs.detectives[selectedDetective].acted = true;
                            }
                        }
                        // selected the next detective
                        if (cs.detectives[selectedDetective].acted) {
                            if (selectedDetective < 2)
                                selectedDetective++;
                            else 
                                selectedDetective = null;
                        }
                    }
                }
            }
            if (cs.detectives.every(d => d.acted)) {
                cs.detectives.forEach(d => {
                    d.moved = false;
                    d.acted = false;
                    d.checked = [];
                });
                cs.turn = TURN_JACKMOVE;
            }
        }
    }

    if (editorMode) {
        selectedDetective = null;
    } else {
        clickedNodeIndex = null;
        rightClickedNodeIndex = null;
    }

    draw();
}

function getNodeNear(x, y, radius = 0.14) {
    for (const [nodeIndex, jackNode] of graph.entries()) {
        const dx = x - jackNode.pos.x*scaleFactor;
        const dy = y - jackNode.pos.y*scaleFactor;
        // TODO: base radius off node type
        if (Math.sqrt(dx*dx + dy*dy) < radius*scaleFactor) {
            return nodeIndex;
        }
    }
    return null;
}

function mousedown(e) {
    if (editorMode) {
        if (e.button == LEFT_BUTTON) {
            if (rightClickedNodeIndex == null) {
                clickedNodeIndex = getNodeNear(e.clientX, e.clientY);
                if (clickedNodeIndex) {
                    clickedNodeOriginalPos = Object.assign({}, graph[clickedNodeIndex].pos);
                }
            } else {
                let dstIndex = getNodeNear(e.clientX, e.clientY);
                if (dstIndex == null) {
                    rightClickedNodeIndex = null;
                } else {
                    if (graph[rightClickedNodeIndex].type == 'j' && graph[dstIndex].type == 'j') {
                        console.log('cannot connect two jack nodes directly');
                    } else if (rightClickedNodeIndex == dstIndex) {
                        console.log('cannot connect a node to itself');
                    } else {
                        if (!graph[rightClickedNodeIndex].neighbors.includes(dstIndex)) {
                            actionStack.push({type: 'connect', src: rightClickedNodeIndex, dst: dstIndex});
                            redoStack.length = 0;
                            connectNodes(rightClickedNodeIndex, dstIndex);
                        } else {
                            actionStack.push({type: 'disconnect', src: rightClickedNodeIndex, dst: dstIndex});
                            redoStack.length = 0;
                            disconnectNodes(rightClickedNodeIndex, dstIndex);
                        }
                        rightClickedNodeIndex = null;
                    }
                }
            }
        } else if (e.button == RIGHT_BUTTON) {
            rightClickedNodeIndex = getNodeNear(e.clientX, e.clientY);
        }
    } else {
        if (cs.turn == TURN_CHOOSE_LOCATIONS) {
            const chosenQuadrants = [false, false, false, false];
            cs.chosenLocations.forEach(ml => chosenQuadrants[graph[ml].quadrant-1] = true);
            const nodeIndex = getNodeNear(mouseX, mouseY);
            if (nodeIndex != null) {
                if (graph[nodeIndex].type == 'j'                    &&
                    graph[nodeIndex].quadrant != 0                  &&
                    !graph[nodeIndex].boat                          &&
                    !chosenQuadrants[graph[nodeIndex].quadrant-1]) {
                    cs.chosenLocations.push(nodeIndex);
                    if (cs.chosenLocations.length == 4) {
                        cs.turn = TURN_FIRST_MURDER;
                    }
                }
            }
        } else if (cs.turn == TURN_FIRST_MURDER) {
            const nodeIndex = getNodeNear(mouseX, mouseY);
            if (nodeIndex != null) {
                if (cs.chosenLocations.includes(nodeIndex)) {
                    cs.murders.push(nodeIndex);
                    cs.jack.location = nodeIndex;
                    cs.turn = TURN_JACKMOVE;
                }
            }
        } else if (cs.turn == TURN_JACKMOVE) {
            if (cs.chosenLocations.includes(cs.jack.location) && !cs.murders.includes(cs.jack.location)) {
                cs.murders.push(cs.jack.location);
                cs.round++;
                cs.jack.moves = [];
                cs.clues = [];
            }
            if (cs.jack.moves >= 15) {
                cs.turn = TURN_DETECTIVES_WIN;
            }
            const availMoves = jackNodesWithinN(cs.jack.location);
            const nodeIndex = getNodeNear(mouseX, mouseY);
            if (nodeIndex != null) {
                if (availMoves.includes(nodeIndex)) {
                    cs.jack.location = nodeIndex;
                    cs.jack.moves.push(nodeIndex);
                    cs.turn = TURN_DETMOVE;
                }
            }
        } else if (cs.turn == TURN_DETMOVE) {
        } else if (cs.turn == TURN_CLUES) {
        } else if (cs.turn == TURN_JACK_WINS) {
        } else if (cs.turn == TURN_DETECTIVES_WIN) {
        }
    }
    draw();
}

function mouseup(e) {
    if (e.button == LEFT_BUTTON) {
        if (clickedNodeIndex) {
            actionStack.push({type: 'move', nodeIndex: clickedNodeIndex, from: Object.assign({}, clickedNodeOriginalPos), to: Object.assign({}, graph[clickedNodeIndex].pos)});
            redoStack.length = 0;
            clickedNodeIndex = null;
        }
    }
    draw();
}

function mousemove(e) {
    if (editorMode) {
        if (clickedNodeIndex) {
            graph[clickedNodeIndex].pos.x = round(e.clientX / scaleFactor, 1);
            graph[clickedNodeIndex].pos.y = round(e.clientY / scaleFactor, 1);
        }
    }
    mouseX = e.clientX;
    mouseY = e.clientY;
    draw();
}

window.addEventListener('blur', blur);
window.addEventListener('focus', focus);
window.addEventListener('keydown', keydown);
window.addEventListener('resize', resize);
window.addEventListener('mousedown', mousedown);
window.addEventListener('mouseup', mouseup);
window.addEventListener('mousemove', mousemove);
window.addEventListener('contextmenu', event => event.preventDefault());

        </script>
    </body>

</html>
