<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8">
        <meta name ="viewport" content="width=device-width, initial-scale=1.0">
        <title>Chip's Challenge</title>
<style>
body {
    margin: 0;
    overflow: hidden;
}
</style>
    </head>

    <body>
        <canvas id="myCanvas"></canvas>

        <script src="recordings.js"></script>
        <script src="sprites.js"></script>
        <script src="maps.js"></script>
        <script>

"use strict";

// Passwords:
// Level 1:
// Level 2:
// Level 3:
// Level 4:
// Level 5: TQKB
// Level 6: WNLD
// Level 7: FXQO
// Level 8: NHAG
// Level 9: KCRE

// Reference implementation: https://archive.org/details/chips_challenge_windows_3.x

const LEFT_BUTTON = 0;
const RIGHT_BUTTON = 2;

const canvas = document.getElementById('myCanvas');
const ctx = canvas.getContext('2d');
//ctx.imageSmoothingEnabled = false; // TODO: find out why this doesn't work

// TODO: show inventory, timer, number of chips remaining
// TODO: place chips below blocks
// TODO: buttons that move creatures
// TODO: show player facing which way they moved
// TODO: limit player's ability to move while on pushers

// TODO: use something like this instead of strings
//const Tiles = Object.freeze({
//    FLOOR:      0,
//    WALL:       1,
//    BLOCK:      2,
//});

const fixed_dt = 8; // 125 Hz
const MAX_FRAMETIME = 250;

const TIMER_INTERVAL_MS = 100;
const DIR_TIMER_MS = 100;

let sq;
const nr = 23;
const nc = 23;

let width;
let height;
let pressed;
let mouse_down_left = false;
let mouse_down_right = false;
let paused;
let recording = false;
let playback = false;
let editor_mode;
let advanceFrame;
let accumulator;
let frameCount;
let simRate = 1.0;
let simRate_msg;
let simRate_timeout;

let prevTime;
let msg;

let editor_selection;
let editor_panel = {};

// TODO: this is maintained in multiple places; bug-prone!
const tile_names = [
    'BALL_',
    'BLOCK',
    'BK_CP',
    'BK_FR',
    'BOMB_',
    'FLIP_',
    'BOOTG',
    'BOOTR',
    'SKATE',
    'BRDRE',
    'BRDRF',
    'BTNBL',
    'BTNBR',
    'BTNGR',
    'BTNRE',
    'CHIP_',
    'CLONE',
    'CLMAC',
    'END__',
    'FIRE_',
    '     ',
    'HELP_',
    'ICE__',
    'ICEUL',
    'ICELL',
    'KEYC',
    'KEYG',
    'KEYR',
    'KEYY',
    'LOCKC',
    'LOCKG',
    'LOCKR',
    'LOCKY',
    'PLAY_',
    'PUSHR',
    'PUSHL',
    'PUSHU',
    'PUSHD',
    'RAFT_',
    'RAY__',
    'SOCK_',
    'WALL_',
    'WASP_',
    'WATER',
];

(function() {
    let tr=0, tc=-Math.ceil(tile_names.length/nr)-1;
    for (const ti in tile_names) {
        editor_panel[`${tr},${tc}`] = tile_names[ti];
        tr = (tr+1) % nr;
        if (tr == 0)
            tc++;
    }
})();

let cs = {};
let ss = {};

function saveState() {
    ss = JSON.parse(JSON.stringify(cs));
}

function restoreState() {
    cs = JSON.parse(JSON.stringify(ss));
}

function goToLevel(n) {

    if (n < 1)
        return;
    cs.level = n;

    cs.player = {
        keyg: 0,
        keyy: 0,
        keyc: 0,
        keyr: 0,
        boot_red: false,
        boot_green: false,
        boot_flipper: false,
        boot_skate: false,
        dir: ' ',
    };
    cs.wasps = [];
    cs.tanks = [];
    cs.rays = []; // TODO
    cs.balls = [];

    if (n < maps.length)
        cs.map = maps[n];

    if (n == 1) {
        cs.chips = 11; // TODO: count automatically
        cs.player.r = 7; // TODO: find automatically
        cs.player.c = 7;
   } else if (n == 2) {
        cs.chips = 4;
        cs.player.r = 5;
        cs.player.c = 14;
        cs.wasps.push({r: 4, c: 6, dir: 'L', pi: 0, path: ['U', 'U', 'L', 'L', 'D', 'D', 'D', 'D', 'D', 'D', 'R', 'R', 'U', 'U', 'R', 'U', 'U', 'L']});
        cs.wasps.push({r: 5, c: 7, dir: 'U', pi: 0, path: ['U', 'L', 'U', 'U', 'L', 'L', 'D', 'D', 'D', 'D', 'D', 'D', 'R', 'R', 'U', 'U', 'R', 'U']});
        cs.wasps.push({r: 6, c: 6, dir: 'U', pi: 0, path: ['R', 'U', 'U', 'L', 'U', 'U', 'L', 'L', 'D', 'D', 'D', 'D', 'D', 'D', 'R', 'R', 'U', 'U']});
   } else if (n == 3) {
        cs.chips = 4;
        cs.player.r = 10;
        cs.player.c = 7;
   } else if (n == 4) {
        cs.chips = 9;
        cs.player.r = 5;
        cs.player.c = 10;
        cs.tanks.push({r: 1, c: 4, dir: 'U', pi: 0, path: ['D', 'D'], moving: false, reverse: false});
        cs.tanks.push({r: 5, c: 4, dir: 'U', pi: 0, path: ['D', 'D'], moving: false, reverse: false});
   } else if (n == 5) {
        cs.chips = 0;
        cs.player.r = 15;
        cs.player.c = 10;
        cs.balls.push({r: 11, c: 7, dir: 'R'});
    } else {
        // END GAME?
        goToLevel(1);
    }

    // TODO: use camera
    cs.camera = {};
    cs.camera.r = cs.player.r;
    cs.camera.c = cs.player.c;
}

function nextLevel() { goToLevel(cs.level+1); }
function prevLevel() { goToLevel(cs.level-1); }

function reset(level = 1) {
    resize();
    pressed = {};
    paused = false;
    //recording = false;
    //playback = false;
    editor_mode = false;
    advanceFrame = false;
    accumulator = 0;
    frameCount = 0;
    prevTime = 0;

    cs = {
        level: level,
        timer: TIMER_INTERVAL_MS,
        dir_timer: 0,
        dead: false,
    };

    goToLevel(cs.level);
}

reset();
saveState();

function px(x, f=0.0) { return Math.round(x) + f; }

function worldToScreen(coord) {
    return {
        x: width/2 + coord.x*sq - nc*sq/2,
        y: height/2 + coord.y*sq - nr*sq/2,
        w: coord.w * sq,
        h: coord.h * sq,
    };
}

function drawRect(style, rect) {
    ctx.fillStyle = style;
    const sr = worldToScreen(rect);
    ctx.fillRect(px(sr.x), px(sr.y), sr.w, sr.h);
}

function drawTexture(tex, rect) {
    const sr = worldToScreen(rect);
    ctx.drawImage(tex, px(sr.x), px(sr.y), sr.w, sr.h);
}

function drawText(args) {
    const ts = 0.019;
    args = args ?? {}; 
    args.size = args.size ?? 40;
    args.text = args.text ?? "";
    args.ro = args.ro ?? 0;
    args.co = args.co ?? 0;
    args.r = args.r ?? Math.floor(nr/2) + args.ro;
    args.c = args.c ?? Math.floor(nc/2) - Math.floor(args.text.length*ts*args.size/2) + args.co;
    args.fill = args.fill ?? "black";
    //args.stroke = args.stroke ?? "black";
    args.bgfill = args.bgfill ?? "white";
    args.bgstroke = args.bgstroke ?? "black";

    const tr = worldToScreen({x: args.c, y: args.r, w: Math.ceil(args.text.length*ts*args.size), h: 1});
    if (args.bgfill || args.bgstroke) {
        ctx.beginPath();
        ctx.rect(tr.x, tr.y, tr.w, -tr.h);
        ctx.fillStyle = args.bgfill;
        ctx.strokeStyle = args.bgstroke;
        if (args.bgfill) ctx.fill();
        if (args.bgstroke) ctx.stroke();
    }
    ctx.font = `${args.size}px Courier New`;
    ctx.lineWidth = 1;
    ctx.fillStyle = args.fill;
    ctx.strokeStyle = args.stroke;
    const offset = sq/5;
    if (args.fill) ctx.fillText(args.text, tr.x+offset, tr.y-offset);
    if (args.stroke) ctx.strokeText(args.text, tr.x+offset, tr.y-offset);
}

function tile_name_to_tex(m)
{
    let tex = null;
    if      (m === null)    tex = help_tex;
    else if (m == 'BALL_')  tex = ball_tex;
    else if (m == 'BLOCK')  tex = block_tex;
    else if (m == 'BK_CP')  tex = block_tex;
    else if (m == 'BK_FR')  tex = block_tex;
    else if (m == 'BOMB_')  tex = bomb_tex;
    else if (m == 'FLIP_')  tex = boot_flipper_tex;
    else if (m == 'BOOTG')  tex = boot_green_tex;
    else if (m == 'BOOTR')  tex = boot_red_tex;
    else if (m == 'SKATE')  tex = boot_skate_tex;
    else if (m == 'BRDRE')  tex = border_empty_tex;
    else if (m == 'BRDRF')  tex = border_full_tex;
    else if (m == 'X')      tex = button_big_brown_tex;
    else if (m == 'X')      tex = button_big_cyan_tex;
    else if (m == 'X')      tex = button_big_gray_tex;
    else if (m == 'BTNBL')  tex = button_blue_tex;
    else if (m == 'BTNBR')  tex = button_brown_tex;
    else if (m == 'BTNGR')  tex = button_green_tex;
    else if (m == 'BTNRE')  tex = button_red_tex;
    else if (m == 'CHIP_')  tex = chip_tex;
    else if (m == 'CLONE')  tex = clone_tex;
    else if (m == 'CLMAC')  tex = clone_machine_tex;
    else if (m == 'END__')  tex = end_tex;
    else if (m == 'FIRE_')  tex = fire_tex;
    else if (m == '     ')  tex = floor_tex;
    else if (m == 'X')      tex = floor_edge_tex;
    else if (m == 'X')      tex = gravel_tex;
    else if (m == 'HELP_')  tex = help_tex;
    else if (m == 'ICE__')  tex = ice_tex;
    else if (m == 'ICEUL')  tex = ice_ul_tex;
    else if (m == 'ICELL')  tex = ice_ll_tex;
    else if (m.substr(0,4) == 'KEYC')  tex = key_cyan_tex;
    else if (m.substr(0,4) == 'KEYG')  tex = key_green_tex;
    else if (m.substr(0,4) == 'KEYR')  tex = key_red_tex;
    else if (m.substr(0,4) == 'KEYY')  tex = key_yellow_tex;
    else if (m == 'LOCKC')  tex = lock_cyan_tex;
    else if (m == 'LOCKG')  tex = lock_green_tex;
    else if (m == 'LOCKR')  tex = lock_red_tex;
    else if (m == 'LOCKY')  tex = lock_yellow_tex;
    else if (m == 'X')      tex = monster_back_tex;
    else if (m == 'X')      tex = monster_front_tex;
    else if (m == 'X')      tex = monster_left_tex;
    else if (m == 'X')      tex = monster_right_tex;
    else if (m == 'X')      tex = player_back_tex;
    else if (m == 'PLAY_')  tex = player_front_tex;
    else if (m == 'X')      tex = player_left_tex;
    else if (m == 'X')      tex = player_right_tex;
    else if (m == 'PUSHR')  tex = push_right_tex;
    else if (m == 'PUSHL')  tex = push_left_tex;
    else if (m == 'PUSHU')  tex = push_up_tex;
    else if (m == 'PUSHD')  tex = push_down_tex;
    else if (m == 'RAFT_')  tex = raft_tex;
    else if (m == 'RAY__')  tex = ray_tex;
    else if (m == 'SOCK_')  tex = socket_tex;
    else if (m == 'X')      tex = tank_up_tex;
    else if (m == 'X')      tex = tank_down_tex;
    else if (m == 'X')      tex = tank_left_tex;
    else if (m == 'X')      tex = tank_right_tex;
    else if (m == 'X')      tex = thief_tex;
    else if (m == 'X')      tex = swim_back_tex;
    else if (m == 'X')      tex = swim_front_tex;
    else if (m == 'X')      tex = swim_left_tex;
    else if (m == 'X')      tex = swim_right_tex;
    else if (m == 'WALL_')  tex = wall_tex;
    else if (m == 'X')      tex = wall_blue_tex;
    else if (m == 'WASP_')  tex = wasp_tex;
    else if (m == 'WATER')  tex = water_tex;
    else                    tex = help_tex;
    return tex;
}

function draw() {
    ctx.clearRect(0, 0, width, height);

    for (let r = 0; r < nr; r++) {
        for (let c = 0; c < nc; c++) {
            const rm = cs.camera.r - Math.floor(nr/2) + r;
            const cm = cs.camera.c - Math.floor(nc/2) + c;
            let m;
            if (rm < 0 || cm < 0 || rm >= cs.map.length || cm >= cs.map[0].length) m = null;
            else m = cs.map[rm][cm];
            let tex = tile_name_to_tex(m);
            drawTexture(tex, {x: c, y: r, w: 1, h: 1});
        }
    }

    let player_tex = player_front_tex;
    const player_tile = cs.map[cs.player.r][cs.player.c];

    if (player_tile == '     ') {
        if (cs.player.dir == ' ')
            player_tex = player_front_tex;
        else if (cs.player.dir == 'U')
            player_tex = player_back_tex;
        else if (cs.player.dir == 'D')
            player_tex = player_front_tex;
        else if (cs.player.dir == 'L')
            player_tex = player_left_tex;
        else if (cs.player.dir == 'R')
            player_tex = player_right_tex;
    } else if (player_tile == 'FIRE_') {
        if (!cs.player.boot_flipper) {
            player_tex = burn_tex;
        } else {
            player_tex = player_front_tex; // TODO
        }
    } else if (player_tile == 'WATER') {
        if (!cs.player.boot_flipper) {
            player_tex = splash_tex;
        } else {
            if (cs.player.dir == ' ')
                player_tex = swim_front_tex;
            else if (cs.player.dir == 'U')
                player_tex = swim_back_tex;
            else if (cs.player.dir == 'D')
                player_tex = swim_front_tex;
            else if (cs.player.dir == 'L')
                player_tex = swim_left_tex;
            else if (cs.player.dir == 'R')
                player_tex = swim_right_tex;
        }
    } else if (player_tile.substr(0,3) == 'ICE') {
        if (cs.player.dir == ' ')
            player_tex = player_ice_front_tex;
        else if (cs.player.dir == 'U')
            player_tex = player_ice_back_tex;
        else if (cs.player.dir == 'D')
            player_tex = player_ice_front_tex;
        else if (cs.player.dir == 'L')
            player_tex = player_ice_left_tex;
        else if (cs.player.dir == 'R')
            player_tex = player_ice_right_tex;
    }

    const rp = Math.floor(nr/2) + cs.player.r - cs.camera.r;
    const cp = Math.floor(nc/2) + cs.player.c - cs.camera.c;
    drawTexture(player_tex, {x: cp, y: rp, w: 1, h: 1});

    // TODO: DRY this code

    for (const tank of cs.tanks) {
        const rt = Math.floor(nr/2) + tank.r - cs.camera.r;
        const ct = Math.floor(nc/2) + tank.c - cs.camera.c;
        if (rt < 0 || rt >= nr || ct < 0 || ct >= nc)
            continue;
        // TODO: choose tank_tex based on tank.dir
        drawTexture(tank_up_tex, {x: ct, y: rt, w: 1, h: 1});
    }

    for (const wasp of cs.wasps) {
        const rw = Math.floor(nr/2) + wasp.r - cs.camera.r;
        const cw = Math.floor(nc/2) + wasp.c - cs.camera.c;
        if (rw < 0 || rw >= nr || cw < 0 || cw >= nc)
            continue;
        // TODO: choose wasp_tex based on wasp.dir
        drawTexture(wasp_tex, {x: cw, y: rw, w: 1, h: 1});
    }

    for (const ball of cs.balls) {
        const rb = Math.floor(nr/2) + ball.r - cs.camera.r;
        const cb = Math.floor(nc/2) + ball.c - cs.camera.c;
        if (rb < 0 || rb >= nr || cb < 0 || cb >= nc)
            continue;
        drawTexture(ball_tex, {x: cb, y: rb, w: 1, h: 1});
    }

    if (recording)
        drawText({r: 0, text: "RECORDING"});
    if (playback)
        drawText({r: 0, text: "PLAYBACK"});
    if (paused)
        drawText({text: "PAUSED"});
    if (editor_mode) {
        drawText({r: 0, text: "EDITOR"});
        const sel_cmin = Math.min(editor_selection.ca, editor_selection.cb);
        const sel_rmin = Math.min(editor_selection.ra, editor_selection.rb);
        const sel_w = Math.abs(editor_selection.cb - editor_selection.ca) + 1;
        const sel_h = Math.abs(editor_selection.rb - editor_selection.ra) + 1;
        drawRect("hsla(240, 50%, 50%, 0.5)", {x: sel_cmin, y: sel_rmin, w: sel_w, h: sel_h});

        let tr=0, tc=-Math.ceil(tile_names.length/nr)-1;
        for (const ti in tile_names) {
            const tex = tile_name_to_tex(tile_names[ti]);
            drawTexture(tex, {x: tc, y: tr, w: 1, h: 1});
            tr = (tr+1) % nr;
            if (tr == 0)
                tc++;
        }
    }

    if (cs.dead) {
        drawText({text: msg, size: 20});
        drawText({ro: 2, text: "Press r to restart", size: 20});
    }

    if (simRate_msg !== undefined)
        drawText({text: simRate_msg, size: 30});
}

function canGo(dr, dc)
{
    const r = cs.player.r + dr;
    const c = cs.player.c + dc;
    const r2 = cs.player.r + 2*dr;
    const c2 = cs.player.c + 2*dc;

    if (cs.map[r][c] == 'BLOCK' || cs.map[r][c].substr(0,3) == 'BK_') {
        if (cs.map[r2][c2] == '     ')
            return true;
        else if (cs.map[r2][c2] == 'WATER')
            return true;
        else
            return false;
    }

    if (cs.map[r][c] == 'BRDRF')
        return false;

    if (cs.map[r][c] == 'WALL_')
        return false;

    if (cs.map[r][c] == 'LOCKR' && cs.player.keyr == 0)
        return false;
    if (cs.map[r][c] == 'LOCKY' && cs.player.keyy == 0)
        return false;
    if (cs.map[r][c] == 'LOCKC' && cs.player.keyc == 0)
        return false;
    if (cs.map[r][c] == 'LOCKG' && cs.player.keyg == 0)
        return false;

    if (cs.map[r][c] == 'SOCK_' && cs.chips > 0)
        return false;

    return true;
}

function move(dr, dc)
{
    const r = cs.player.r + dr;
    const c = cs.player.c + dc;
    const r2 = cs.player.r + 2*dr;
    const c2 = cs.player.c + 2*dc;

    if (cs.map[r][c].substr(0,4) == 'LOCK') {
        const color = cs.map[r][c].substr(4,1);
        if      (color == 'C') cs.player.keyc--;
        else if (color == 'G') cs.player.keyg--;
        else if (color == 'R') cs.player.keyr--;
        else if (color == 'Y') cs.player.keyy--;
        cs.map[r][c] = '     ';
    }

    if (cs.map[r][c] == 'BOOTR') {
        cs.map[r][c] = '     ';
        cs.player.boot_red = true;
    }
    if (cs.map[r][c] == 'BOOTG') {
        cs.map[r][c] = '     ';
        cs.player.boot_green = true;
    }
    if (cs.map[r][c] == 'FLIP_') {
        cs.map[r][c] = '     ';
        cs.player.boot_flipper = true;
    }
    if (cs.map[r][c] == 'SKATE') {
        cs.map[r][c] = '     ';
        cs.player.boot_skate = true;
    }

    // keys
    if (cs.map[r][c].substr(0,3) == 'KEY') {
        const color = cs.map[r][c].substr(3,1);
        const n = parseInt(cs.map[r][c].substr(4,1));
        if      (color == 'C') cs.player.keyc += n;
        else if (color == 'G') cs.player.keyg += n;
        else if (color == 'R') cs.player.keyr += n;
        else if (color == 'Y') cs.player.keyy += n;
        cs.map[r][c] = '     ';
    }

    if (cs.map[r][c] == 'RAFT_') {
        cs.map[r][c] = '     ';
    }

    if (cs.map[r][c] == 'BLOCK') {
        cs.map[r][c] = '     ';
        if (cs.map[r2][c2] == 'WATER')
            cs.map[r2][c2] = 'RAFT_';
        else
            cs.map[r2][c2] = 'BLOCK';
    }

    // BLOCKs with things underneath
    if (cs.map[r][c].substr(0,3) == 'BK_') {
        if (cs.map[r][c] == 'BK_CP') {
            cs.map[r][c] = 'CHIP_'; // TODO: make it more obvious that a chip was picked up
        } else if (cs.map[r][c] == 'BK_FR') {
            cs.map[r][c] = 'FIRE_';
        }
        if (cs.map[r2][c2] == 'WATER')
            cs.map[r2][c2] = 'RAFT_';
        else
            cs.map[r2][c2] = 'BLOCK';
    }

    if (cs.map[r][c] == 'BTNBL') {
        for (const tank of cs.tanks)
            tank.moving = true;
    }

    if (cs.map[r][c] == 'BTNRE') {
        console.log('TODO: red button');
    }

    if (cs.map[r][c] == 'BTNGR') {
        for (let rx = 0; rx < cs.map.length; rx++) {
            for (let cx = 0; cx < cs.map[0].length; cx++) {
                if      (cs.map[rx][cx] == 'BRDRE') cs.map[rx][cx] = 'BRDRF';
                else if (cs.map[rx][cx] == 'BRDRF') cs.map[rx][cx] = 'BRDRE';
            }
        }
    }

    if (cs.map[r][c] == 'THIEF') {
        cs.player.keyr = 0;
        cs.player.keyg = 0;
        cs.player.keyy = 0;
        cs.player.keyc = 0;
        cs.boot_red = false;
        cs.boot_green = false;
        cs.boot_flipper = false;
        cs.boot_skate = false;
    }

    cs.player.r = r;
    cs.player.c = c;
    cs.camera.r = cs.player.r;
    cs.camera.c = cs.player.c;

    if      (dr > 0) cs.player.dir = 'D';
    else if (dr < 0) cs.player.dir = 'U';
    else if (dc > 0) cs.player.dir = 'R';
    else if (dc < 0) cs.player.dir = 'L';

    for (const tank of cs.tanks) {
        if (tank.r == r && tank.c == c) {
            msg = "Look out for creatures!";
            cs.dead = true;
        }
    }

    for (const wasp of cs.wasps) {
        if (wasp.r == r && wasp.c == c) {
            msg = "Look out for creatures!";
            cs.dead = true;
        }
    }

    if (cs.map[r][c] == 'FIRE_' && !cs.player.boot_red) {
        msg = "Oops! Don't step in the fire without fire boots!";
        cs.dead = true;
    }

    if (cs.map[r][c] == 'WATER' && !cs.player.boot_flipper) {
        msg = "Oops! Chip can't swim without flippers!";
        cs.dead = true;
    }

    if (cs.map[r][c] == 'CHIP_') {
        cs.map[r][c] = '     ';
        cs.chips--;
    }

    if (cs.map[r][c] == 'SOCK_') {
        cs.map[r][c] = '     ';
    }

    if (cs.map[r][c] == 'END__') {
        nextLevel();
    }
}

function handleInput(t, dt) {

    // don't allow movement while on ice; TODO: is this right?
    const player_tile = cs.map[cs.player.r][cs.player.c];
    if (player_tile.substr(0,3) == 'ICE' && !cs.player.boot_skate)
        return;

    let dr = 0, dc = 0;

    let arrow_key_pressed = pressed.ArrowLeft || pressed.ArrowRight || pressed.ArrowUp || pressed.ArrowDown;

    if (arrow_key_pressed && cs.dir_timer <= 0) {
        if (pressed.ArrowLeft)  { dc = -1; }
        if (pressed.ArrowRight) { dc =  1; }
        if (pressed.ArrowUp)    { dr = -1; }
        if (pressed.ArrowDown)  { dr =  1; }
        cs.dir_timer = DIR_TIMER_MS;
        pressed = {};
    }

    if (dr != 0 || dc != 0) {
        if (canGo(dr, dc))
            move(dr, dc);
    }

    if (arrow_key_pressed) {
        if (pressed.ArrowLeft)  { cs.player.dir = 'L'; }
        if (pressed.ArrowRight) { cs.player.dir = 'R'; }
        if (pressed.ArrowUp)    { cs.player.dir = 'U'; }
        if (pressed.ArrowDown)  { cs.player.dir = 'D'; }
    }
}

function update(t, dt) {

    if (cs.dir_timer > 0) {
        cs.dir_timer -= dt;
    }

    if (cs.timer > 0) {
        cs.timer -= dt;
        return;
    }
    cs.timer += TIMER_INTERVAL_MS;
    // TODO: wasps should only update ever other tick

    for (const tank of cs.tanks) {
        if (!tank.moving)
            continue;
        let d = tank.path[tank.pi];
        if (tank.reverse) {
            if      (d == 'U')  d = 'D';
            else if (d == 'D')  d = 'U';
            else if (d == 'L')  d = 'R';
            else if (d == 'R')  d = 'L';
        }
        if (d == 'U') {
            tank.r--;
            tank.dir = 'U';
        } else if (d == 'L') {
            tank.c--;
            tank.dir = 'L';
        } else if (d == 'R') {
            tank.c++;
            tank.dir = 'R';
        } else if (d == 'D') {
            tank.r++;
            tank.dir = 'D';
        }

        if (tank.reverse)   tank.pi--;
        else                tank.pi++;

        if (tank.pi == tank.path.length) {
            tank.moving = false;
            tank.reverse = true;
            tank.pi--;
        } else if (tank.pi == -1) {
            tank.moving = false;
            tank.reverse = false;
            tank.pi++;
        }
    }

    for (const wasp of cs.wasps) {
        const d = wasp.path[wasp.pi];
        if (d == 'U') {
            wasp.r--;
            wasp.dir = 'U';
        } else if (d == 'L') {
            wasp.c--;
            wasp.dir = 'L';
        } else if (d == 'R') {
            wasp.c++;
            wasp.dir = 'R';
        } else if (d == 'D') {
            wasp.r++;
            wasp.dir = 'D';
        }
        wasp.pi = (wasp.pi + 1) % wasp.path.length;
    }

    for (const ball of cs.balls) {
        // TODO: ball should bounce off border walls, too
        // TODO: ball should activate buttons
        // TODO: DRY this code
        if (ball.dir == 'R') {
            ball.c++;
            const btile = cs.map[ball.r][ball.c];
            if (btile == 'WALL_' || btile == 'BRDRF') {
                ball.c--;
                ball.dir = 'L';
            }
            if (btile == 'BTNRE') {
            }
        } else {
            ball.c--;
            const btile = cs.map[ball.r][ball.c];
            if (btile == 'WALL_' || btile == 'BRDRF') {
                ball.c++;
                ball.dir = 'R';
            }
            if (btile == 'BTNRE') {
            }
        }
    }

    const player_tile = cs.map[cs.player.r][cs.player.c];

    if (player_tile.substr(0,3) == 'ICE' && !cs.player.boot_skate) {
        // TODO: move player in direction they were going, redirect at corners
        if (player_tile == 'ICE__') {
            if      (cs.player.dir == 'L') cs.player.c--;
            else if (cs.player.dir == 'R') cs.player.c++;
            else if (cs.player.dir == 'U') cs.player.r--;
            else if (cs.player.dir == 'D') cs.player.r++;
        } else if (player_tile == 'ICEUL') {
            if      (cs.player.dir == 'L') { cs.player.dir = 'D'; cs.player.r++;    }
            else if (cs.player.dir == 'R') { cs.player.dir = ' ';                   }
            else if (cs.player.dir == 'U') { cs.player.dir = 'R'; cs.player.c++;    }
            else if (cs.player.dir == 'D') { cs.player.dir = ' ';                   }
        } else if (player_tile == 'ICELL') {
            if      (cs.player.dir == 'L') { cs.player.dir = 'U'; cs.player.r--;    }
            else if (cs.player.dir == 'R') { cs.player.dir = ' ';                   }
            else if (cs.player.dir == 'U') { cs.player.dir = ' ';                   }
            else if (cs.player.dir == 'D') { cs.player.dir = 'R'; cs.player.c++;    }
        } else if (player_tile == 'ICEUR') {
            console.error('TODO!');
        } else if (player_tile == 'ICELR') {
            console.error('TODO!');
        }
    }

    if (player_tile.substr(0,4) == 'PUSH' && !cs.player.boot_green) {
        if (player_tile == 'PUSHL')
            cs.player.c--;
        else if (player_tile == 'PUSHR')
            cs.player.c++;
        else if (player_tile == 'PUSHU')
            cs.player.r--;
        else if (player_tile == 'PUSHD')
            cs.player.r++;
    }

    cs.camera.r = cs.player.r;
    cs.camera.c = cs.player.c;
}

function simulateInputOnFrame(n, verbose=true) {
    if (n in inputsToSim) {
        for (let input of inputsToSim[n]) {
            if (verbose) { console.log(`input '${input.key}' ${input.mode} on frame ${n}`); }
            let e = {key: input.key};
            if (input.mode == 'down')   { keydown(e); }
            else                        { keyup(e); }
        }
    }
}

function loop(t) {
    let frameTime = t - prevTime;
    prevTime = t;

    if (!editor_mode && !cs.dead && (!paused || advanceFrame)) {

        if (frameTime > MAX_FRAMETIME) {
            console.log(`frameTime > MAX_FRAMETIME : ${frameTime}`);
            frameTime = MAX_FRAMETIME;
        }

        accumulator += frameTime * simRate;

        while (accumulator >= fixed_dt) {
            frameCount++;
            if (playback) {
                simulateInputOnFrame(frameCount);
                if (frameCount > last_playback_frame)
                    playback = false;
            }
            handleInput(t, fixed_dt);
            update(t, fixed_dt);
            accumulator -= fixed_dt;
        }
        advanceFrame = false;
    }
    draw();
    window.requestAnimationFrame(loop);
}

loop(0);

function blur(e) {
    if (!editor_mode)
        paused = true;
}

function focus(e) {
    //paused = false;
}

function resize(e) {
    width = canvas.width = window.innerWidth;
    height = canvas.height = window.innerHeight;
    const sqh = Math.round(height/(nr+1));
    const sqw = Math.round(width/(nc+1));
    //sq = 32;
    sq = Math.min(sqh, sqw, 32);
}

function mouse_get_tile_info(x, y)
{
    let rv = {};
    rv.c = Math.floor((x - width/2 + (sq*nc/2))/sq);
    rv.r = Math.floor((y - height/2 + (sq*nr/2))/sq);
    rv.tile_name = editor_panel[`${rv.r},${rv.c}`];
    rv.rm = cs.camera.r - Math.floor(nr/2) + rv.r;
    rv.cm = cs.camera.c - Math.floor(nc/2) + rv.c;
    rv.valid = rv.rm >= 0 && rv.cm >= 0 && rv.rm < cs.map.length && rv.cm < cs.map[0].length;
    rv.m = rv.valid ? rv.m = cs.map[rv.rm][rv.cm] : null;
    return rv;
}

function mousedown(e) {
    if (e.button == LEFT_BUTTON) mouse_down_left = true;

    if (editor_mode) {
        if (e.button != LEFT_BUTTON)
            return;

        const tile_info = mouse_get_tile_info(e.clientX, e.clientY);

        if (tile_info.tile_name === undefined) {
            editor_selection = {};
            if (tile_info.valid) {
                editor_selection.rb = editor_selection.ra = tile_info.r;
                editor_selection.cb = editor_selection.ca = tile_info.c;
            }
        } else {
            const sel_cmin = Math.min(editor_selection.ca, editor_selection.cb);
            const sel_rmin = Math.min(editor_selection.ra, editor_selection.rb);
            const sel_w = Math.abs(editor_selection.cb - editor_selection.ca) + 1;
            const sel_h = Math.abs(editor_selection.rb - editor_selection.ra) + 1;
            for (let r = sel_rmin; r < sel_rmin + sel_h; r++) {
                for (let c = sel_cmin; c < sel_cmin + sel_w; c++) {
                    const rm = cs.camera.r - Math.floor(nr/2) + r;
                    const cm = cs.camera.c - Math.floor(nc/2) + c;
                    cs.map[rm][cm] = tile_info.tile_name;
                }
            }
        }
    }
}

function mouseup(e) {
    if (e.button == LEFT_BUTTON) mouse_down_left = false;
}

function mousemove(e) {
    if (editor_mode) {
        if (!mouse_down_left)
            return;
        const tile_info = mouse_get_tile_info(e.clientX, e.clientY);
        if (tile_info.valid) {
            editor_selection.rb = tile_info.r;
            editor_selection.cb = tile_info.c;
        }
    }
}

function startRecording()
{
    recording = true;
    reset(cs.level);
    inputsToSim = {};
}

function stopRecording()
{
    last_playback_frame = frameCount;
    recording = false;
    console.log(inputsToSim);
}

function keydown(e) {
    if (!editor_mode) {
        if (e.key === 'Escape') {
            paused = !paused;
        } else if (e.key === 'n') {
            nextLevel();
        } else if (e.key === 'p') {
            prevLevel();
        } else if (e.key === 's') {
            saveState();
        } else if (e.key === 'd') {
            restoreState();
        } else if (e.key === ',' || e.key === '.') {
            if (e.key === ',')
                simRate /= 2;
            else if (e.key === '.')
                simRate *= 2;
            simRate_msg = `simRate: ${simRate}`;
            if (simRate_timeout !== undefined) clearTimeout(simRate_timeout);
            simRate_timeout = setTimeout(function() { simRate_msg = undefined; }, 1000);
            console.log(`simRate: ${simRate}`);
        } else if (e.key === '`') {
            advanceFrame = true;
        } else if (e.key === 'u') {
            // TODO: undo!
        } else if (e.key === 'U') {
            // TODO: redo!
        } else if (e.key === 'e') {
            editor_mode = true;
            editor_selection = {};
            paused = false;
        } else if (e.key === 'R') {
            if (!recording) startRecording();
            else            stopRecording();
        } else if (e.key === 'P') {
            if (recording)
                stopRecording();
            playback = !playback;
            if (playback)
                reset(cs.level);
        } else if (e.key === 'r') {
            reset(cs.level);
        } else {
            if (recording) {
                if (!(frameCount in inputsToSim))
                    inputsToSim[frameCount] = [];
                inputsToSim[frameCount].push({key: e.key, mode: 'down'});
            }
            pressed[e.key] = true;
        }
    } else {
        if (e.key === 'Escape') {
            editor_selection = {};
        } else if (e.key === 'e') {
            console.log(cs.map); // TODO: output the map
            editor_mode = false;
            cs.camera.r = cs.player.r;
            cs.camera.c = cs.player.c;
        } else if (e.key === 'ArrowUp') {
            cs.camera.r--;
        } else if (e.key === 'ArrowDown') {
            cs.camera.r++;
        } else if (e.key === 'ArrowLeft') {
            cs.camera.c--;
        } else if (e.key === 'ArrowRight') {
            cs.camera.c++;
        } else {
        }
    }
}

function keyup(e) {
    if (!editor_mode) {
        if (e.key === 'Escape') {
        } else if (e.key === 'r') {
        } else {
            if (recording) {
                if (!(frameCount in inputsToSim))
                    inputsToSim[frameCount] = [];
                inputsToSim[frameCount].push({key: e.key, mode: 'up'});
            }
            pressed[e.key] = false;
        }
    } else {
    }
}

window.addEventListener('blur', blur);
window.addEventListener('focus', focus);
window.addEventListener('mousedown', mousedown);
window.addEventListener('mouseup', mouseup);
window.addEventListener('mousemove', mousemove);
window.addEventListener('keydown', keydown);
window.addEventListener('keyup', keyup);
window.addEventListener('resize', resize);

        </script>
    </body>

</html>
