<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8">
        <meta name ="viewport" content="width=device-width, initial-scale=1.0">
        <title>Chip's Challenge</title>
<style>
body {
    margin: 0;
    overflow: hidden;
}
</style>
    </head>

    <body>
        <canvas id="myCanvas"></canvas>

        <script src="inputs.js"></script>
        <script src="sprites.js"></script>
        <script>

"use strict";

// Passwords:
// Level 1:
// Level 2:
// Level 3:
// Level 4:
// Level 5: TQKB
// Level 6: WNLD
// Level 7: FXQO
// Level 8: NHAG
// Level 9: KCRE

// Reference implementation: https://archive.org/details/chips_challenge_windows_3.x

const LEFT_BUTTON = 0;
const RIGHT_BUTTON = 2;

const canvas = document.getElementById('myCanvas');
const ctx = canvas.getContext('2d');
//ctx.imageSmoothingEnabled = false; // TODO: find out why this doesn't work

// TODO: show inventory, timer, number of chips remaining
// TODO: place chips below blocks
// TODO: buttons that move creatures
// TODO: show player facing which way they moved
// TODO: limit player's ability to move while on pushers

// TODO: use something like this instead of strings
//const Tiles = Object.freeze({
//    FLOOR:      0,
//    WALL:       1,
//    BLOCK:      2,
//});

const fixed_dt = 8; // 125 Hz
const MAX_FRAMETIME = 250;

const TIMER_INTERVAL_MS = 100;
const DIR_TIMER_MS = 100;

let sq;
const nr = 23;
const nc = 23;

let width;
let height;
let pressed;
let mouse_down_left = false;
let mouse_down_right = false;
let paused;
let recording = false;
let playback = false;
let editor_mode;
let advanceFrame;
let accumulator;
let frameCount;
let simRate = 1.0;
let prevTime;

let editor_selection;

let cs = {};
let ss = {};

//let last_playback_frame;
//let inputsToSim = {};

function saveState() {
    ss = JSON.parse(JSON.stringify(cs));
}

function restoreState() {
    cs = JSON.parse(JSON.stringify(ss));
}

function goToLevel(n) {

    if (n < 1)
        return;
    cs.level = n;

    cs.player = {
        keyg: 0,
        keyy: 0,
        keyc: 0,
        keyr: 0,
        boot_red: false,
        boot_green: false,
        boot_flipper: false,
        boot_skate: false,
        dir: ' ',
    };
    cs.wasps = [];
    cs.tanks = [];

    if (n == 1) {
        cs.map = [
            ['     ', '     ', 'WALL_', 'WALL_', 'WALL_', 'WALL_', 'WALL_', '     ', 'WALL_', 'WALL_', 'WALL_', 'WALL_', 'WALL_', '     ', '     '],
            ['     ', '     ', 'WALL_', '     ', '     ', '     ', 'WALL_', 'WALL_', 'WALL_', '     ', '     ', '     ', 'WALL_', '     ', '     '],
            ['     ', '     ', 'WALL_', '     ', 'CHIP_', '     ', 'WALL_', 'END__', 'WALL_', '     ', 'CHIP_', '     ', 'WALL_', '     ', '     '],
            ['WALL_', 'WALL_', 'WALL_', 'WALL_', 'WALL_', 'LOCKG', 'WALL_', 'SOCK_', 'WALL_', 'LOCKG', 'WALL_', 'WALL_', 'WALL_', 'WALL_', 'WALL_'],
            ['WALL_', '     ', 'KEYY1', '     ', 'LOCKC', '     ', '     ', '     ', '     ', '     ', 'LOCKR', '     ', 'KEYY1', '     ', 'WALL_'],
            ['WALL_', '     ', 'CHIP_', '     ', 'WALL_', 'KEYC1', '     ', 'HELP_', '     ', 'KEYR1', 'WALL_', '     ', 'CHIP_', '     ', 'WALL_'],
            ['WALL_', 'WALL_', 'WALL_', 'WALL_', 'WALL_', 'CHIP_', '     ', '     ', '     ', 'CHIP_', 'WALL_', 'WALL_', 'WALL_', 'WALL_', 'WALL_'],
            ['WALL_', '     ', 'CHIP_', '     ', 'WALL_', 'KEYC1', '     ', '     ', '     ', 'KEYR1', 'WALL_', '     ', 'CHIP_', '     ', 'WALL_'],
            ['WALL_', '     ', '     ', '     ', 'LOCKR', '     ', '     ', 'CHIP_', '     ', '     ', 'LOCKC', '     ', '     ', '     ', 'WALL_'],
            ['WALL_', 'WALL_', 'WALL_', 'WALL_', 'WALL_', 'WALL_', 'LOCKY', 'WALL_', 'LOCKY', 'WALL_', 'WALL_', 'WALL_', 'WALL_', 'WALL_', 'WALL_'],
            ['     ', '     ', '     ', '     ', 'WALL_', '     ', '     ', 'WALL_', '     ', '     ', 'WALL_', '     ', '     ', '     ', '     '],
            ['     ', '     ', '     ', '     ', 'WALL_', '     ', 'CHIP_', 'WALL_', 'CHIP_', '     ', 'WALL_', '     ', '     ', '     ', '     '],
            ['     ', '     ', '     ', '     ', 'WALL_', '     ', '     ', 'WALL_', 'KEYG2', '     ', 'WALL_', '     ', '     ', '     ', '     '],
            ['     ', '     ', '     ', '     ', 'WALL_', 'WALL_', 'WALL_', 'WALL_', 'WALL_', 'WALL_', 'WALL_', '     ', '     ', '     ', '     '],
        ];
        cs.chips = 11; // TODO: count automatically
        cs.player.r = 7; // TODO: find automatically
        cs.player.c = 7;
   } else if (n == 2) {
        cs.map = [
            ['     ', '     ', 'WALL_', 'WALL_', 'WALL_', 'WALL_', 'WALL_', 'WALL_', 'WALL_', '     ', '     ', '     ', '     ', '     ', '     ', '     ', '     ', '     ', '     ', ],
            ['     ', '     ', 'WALL_', '     ', '     ', 'CHIP_', '     ', '     ', 'WALL_', '     ', '     ', '     ', '     ', '     ', '     ', '     ', '     ', '     ', '     ', ],
            ['     ', '     ', 'WALL_', '     ', '     ', '     ', '     ', '     ', 'WALL_', '     ', '     ', '     ', '     ', '     ', '     ', '     ', '     ', '     ', '     ', ],
            ['     ', '     ', 'WALL_', '     ', '     ', 'WALL_', '     ', '     ', 'WALL_', 'WALL_', 'WALL_', 'WALL_', 'WALL_', 'WALL_', 'WALL_', 'WALL_', 'WALL_', 'WALL_', '     ', ],
            ['WALL_', 'WALL_', 'WALL_', '     ', '     ', 'WALL_', '     ', '     ', '     ', 'WATER', 'WATER', '     ', '     ', '     ', '     ', '     ', 'CHIP_', 'WALL_', '     ', ],
            ['WALL_', 'END__', 'SOCK_', '     ', '     ', 'WALL_', 'WALL_', '     ', '     ', 'WATER', 'WATER', '     ', 'BLOCK', 'BLOCK', '     ', 'HELP_', '     ', 'WALL_', '     ', ],
            ['WALL_', 'WALL_', 'WALL_', '     ', '     ', 'WALL_', '     ', '     ', '     ', 'WATER', 'WATER', '     ', '     ', '     ', '     ', '     ', 'CHIP_', 'WALL_', '     ', ],
            ['     ', '     ', 'WALL_', '     ', '     ', 'WALL_', '     ', '     ', 'WALL_', 'WALL_', 'WALL_', 'WALL_', 'WALL_', 'WALL_', 'WALL_', 'WALL_', 'WALL_', 'WALL_', '     ', ],
            ['     ', '     ', 'WALL_', '     ', '     ', '     ', '     ', '     ', 'WALL_', '     ', '     ', '     ', '     ', '     ', '     ', '     ', '     ', '     ', '     ', ],
            ['     ', '     ', 'WALL_', '     ', '     ', 'CHIP_', '     ', '     ', 'WALL_', '     ', '     ', '     ', '     ', '     ', '     ', '     ', '     ', '     ', '     ', ],
            ['     ', '     ', 'WALL_', 'WALL_', 'WALL_', 'WALL_', 'WALL_', 'WALL_', 'WALL_', '     ', '     ', '     ', '     ', '     ', '     ', '     ', '     ', '     ', '     ', ],
        ];
        cs.chips = 4;
        cs.player.r = 5;
        cs.player.c = 14;
        cs.wasps.push({r: 4, c: 6, dir: 'L', pi: 0, path: ['U', 'U', 'L', 'L', 'D', 'D', 'D', 'D', 'D', 'D', 'R', 'R', 'U', 'U', 'R', 'U', 'U', 'L']});
        cs.wasps.push({r: 5, c: 7, dir: 'U', pi: 0, path: ['U', 'L', 'U', 'U', 'L', 'L', 'D', 'D', 'D', 'D', 'D', 'D', 'R', 'R', 'U', 'U', 'R', 'U']});
        cs.wasps.push({r: 6, c: 6, dir: 'U', pi: 0, path: ['R', 'U', 'U', 'L', 'U', 'U', 'L', 'L', 'D', 'D', 'D', 'D', 'D', 'D', 'R', 'R', 'U', 'U']});
   } else if (n == 3) {
        cs.map = [
            ['     ', '     ', '     ', '     ', '     ', '     ', '     ', 'WALL_', 'WALL_', 'WALL_', '     ', '     ', '     ', '     ', '     ', '     ', ],
            ['     ', '     ', '     ', '     ', '     ', '     ', '     ', 'WALL_', 'END__', 'WALL_', '     ', '     ', '     ', '     ', '     ', '     ', ],
            ['     ', '     ', '     ', 'WALL_', 'WALL_', 'WALL_', 'WALL_', 'WALL_', 'SOCK_', 'WALL_', 'WALL_', 'WALL_', 'WALL_', '     ', '     ', '     ', ],
            ['     ', '     ', '     ', 'WALL_', 'PUSHD', 'PUSHL', 'PUSHL', 'PUSHL', 'PUSHL', 'PUSHL', 'PUSHL', 'PUSHL', 'WALL_', '     ', '     ', '     ', ],
            ['     ', '     ', '     ', 'WALL_', 'PUSHD', 'WALL_', 'WALL_', 'WALL_', 'WALL_', 'WALL_', 'WALL_', 'PUSHU', 'WALL_', '     ', '     ', '     ', ],
            ['WALL_', 'WALL_', 'WALL_', 'WALL_', 'PUSHD', 'WALL_', 'WATER', 'WATER', 'WATER', 'WATER', 'WALL_', 'PUSHU', 'WALL_', 'WALL_', 'WALL_', 'WALL_', ],
            ['WALL_', 'PUSHD', 'PUSHL', 'PUSHL', 'PUSHL', 'WALL_', 'WATER', 'SKATE', 'CHIP_', 'WATER', 'WALL_', 'PUSHU', 'PUSHL', 'PUSHL', 'PUSHL', 'WALL_', ],
            ['WALL_', 'PUSHD', 'WALL_', 'WALL_', 'WALL_', 'WALL_', 'WATER', 'WATER', 'WATER', 'WATER', 'WALL_', 'WALL_', 'WALL_', 'WALL_', 'PUSHU', 'WALL_', ],
            ['WALL_', 'PUSHD', 'WALL_', 'ICEUL', 'ICE__', 'ICE__', '     ', '     ', '     ', '     ', 'FIRE_', 'FIRE_', 'FIRE_', 'WALL_', 'PUSHU', 'WALL_', ],
            ['WALL_', 'PUSHD', 'WALL_', 'ICE__', 'BOOTR', 'WALL_', '     ', '     ', '     ', '     ', 'FIRE_', 'BOOTG', 'FIRE_', 'WALL_', 'PUSHU', 'WALL_', ],
            ['WALL_', 'PUSHD', 'WALL_', 'ICE__', 'CHIP_', 'WALL_', '     ', '     ', 'HELP_', '     ', 'FIRE_', 'CHIP_', 'FIRE_', 'WALL_', 'PUSHU', 'WALL_', ],
            ['WALL_', 'PUSHD', 'WALL_', 'ICELL', 'ICE__', 'ICE__', '     ', '     ', 'FLIP_', '     ', 'FIRE_', 'FIRE_', 'FIRE_', 'WALL_', 'PUSHU', 'WALL_', ],
            ['WALL_', 'PUSHD', 'WALL_', 'WALL_', 'WALL_', 'WALL_', '     ', '     ', '     ', '     ', 'WALL_', 'WALL_', 'WALL_', 'WALL_', 'PUSHU', 'WALL_', ],
            ['WALL_', 'PUSHR', 'PUSHR', 'PUSHR', 'PUSHR', 'PUSHR', 'PUSHU', 'PUSHU', 'PUSHU', 'PUSHR', 'PUSHR', 'PUSHR', 'PUSHR', 'PUSHR', 'PUSHU', 'WALL_', ],
            ['WALL_', 'WALL_', 'WALL_', 'WALL_', 'WALL_', 'WALL_', 'PUSHU', 'CHIP_', 'PUSHU', 'PUSHU', 'WALL_', 'WALL_', 'WALL_', 'WALL_', 'WALL_', 'WALL_', ],
            ['     ', '     ', '     ', '     ', '     ', 'WALL_', 'PUSHU', 'PUSHU', 'PUSHU', 'PUSHU', 'WALL_', '     ', '     ', '     ', '     ', '     ', ],
            ['     ', '     ', '     ', '     ', '     ', 'WALL_', 'WALL_', 'WALL_', 'WALL_', 'WALL_', 'WALL_', '     ', '     ', '     ', '     ', '     ', ],
        ];
        cs.chips = 4;
        cs.player.r = 10;
        cs.player.c = 7;
   } else if (n == 4) {
        cs.map = [
            ['WALL_', 'WALL_', 'WALL_', 'WALL_', 'WALL_', 'WALL_', 'WALL_', 'WALL_', 'WALL_', '     ', '     ', '     ', '     ', '     ', '     ', '     ', '     ', '     ', '     ', '     ', '     ', '     ', ],
            ['WALL_', 'WALL_', '     ', '     ', '     ', '     ', '     ', 'CHIP_', 'WALL_', 'WALL_', 'WALL_', 'WALL_', 'WALL_', 'WALL_', 'WALL_', 'WALL_', 'WALL_', 'WALL_', 'WALL_', 'WALL_', 'WALL_', 'WALL_', ],
            ['WALL_', 'BUTNB', '     ', 'WALL_', '     ', 'WALL_', 'WALL_', 'WALL_', 'WALL_', 'WALL_', '     ', '     ', '     ', '     ', '     ', 'WALL_', '     ', '     ', 'BRDRE', '     ', '     ', 'WALL_', ],
            ['WALL_', 'WALL_', '     ', '     ', '     ', '     ', '     ', 'WALL_', 'WALL_', 'WALL_', 'SOCK_', 'WALL_', 'WALL_', 'END__', '     ', 'WALL_', '     ', '     ', 'WALL_', '     ', 'CHIP_', 'WALL_', ],
            ['WALL_', 'WALL_', 'WALL_', 'WALL_', 'WALL_', 'WALL_', '     ', 'BUTNB', 'WALL_', '     ', '     ', '     ', 'WALL_', 'WALL_', 'WALL_', 'WALL_', '     ', 'BUTNG', 'WALL_', 'WALL_', 'WALL_', 'WALL_', ],
            ['WALL_', 'WALL_', '     ', '     ', '     ', '     ', '     ', 'WALL_', 'WALL_', '     ', '     ', '     ', 'WALL_', '     ', '     ', 'BRDRF', '     ', '     ', 'WALL_', '     ', '     ', 'WALL_', ],
            ['WALL_', 'BUTNB', '     ', 'WALL_', '     ', 'WALL_', 'WALL_', 'WALL_', 'WALL_', '     ', 'HELP_', '     ', 'WALL_', '     ', '     ', 'WALL_', '     ', '     ', 'BRDRF', '     ', 'CHIP_', 'WALL_', ],
            ['WALL_', 'WALL_', '     ', '     ', '     ', '     ', '     ', '     ', '     ', '     ', '     ', '     ', '     ', '     ', 'BUTNG', 'WALL_', 'WALL_', 'WALL_', 'WALL_', 'WALL_', 'WALL_', 'WALL_', ],
            ['WALL_', 'WALL_', 'WALL_', 'WALL_', 'WALL_', 'WALL_', 'WALL_', 'WALL_', 'WALL_', 'WALL_', 'WALL_', '     ', 'WALL_', '     ', '     ', 'WALL_', '     ', '     ', 'BRDRF', '     ', 'CHIP_', 'WALL_', ],
            ['     ', '     ', '     ', '     ', 'WALL_', '     ', '     ', '     ', '     ', '     ', '     ', '     ', 'WALL_', '     ', '     ', 'BRDRE', '     ', '     ', 'WALL_', '     ', '     ', 'WALL_', ],
            ['     ', '     ', '     ', '     ', 'WALL_', '     ', 'BK_CP', '     ', 'BK_CP', '     ', 'WALL_', 'WALL_', 'WALL_', 'WALL_', 'WALL_', 'WALL_', '     ', 'BUTNG', 'WALL_', 'WALL_', 'WALL_', 'WALL_', ],
            ['     ', '     ', '     ', '     ', 'WALL_', '     ', '     ', 'BK_FR', '     ', '     ', 'WALL_', '     ', '     ', '     ', '     ', 'WALL_', '     ', '     ', 'WALL_', '     ', 'CHIP_', 'WALL_', ],
            ['     ', '     ', '     ', '     ', 'WALL_', '     ', 'BK_CP', '     ', 'BK_CP', '     ', 'WALL_', '     ', '     ', '     ', '     ', 'WALL_', '     ', '     ', 'BRDRE', '     ', '     ', 'WALL_', ],
            ['     ', '     ', '     ', '     ', 'WALL_', '     ', '     ', '     ', '     ', '     ', 'WALL_', '     ', '     ', '     ', '     ', 'WALL_', 'WALL_', 'WALL_', 'WALL_', 'WALL_', 'WALL_', 'WALL_', ],
            ['     ', '     ', '     ', '     ', 'WALL_', 'WALL_', 'WALL_', 'WALL_', 'WALL_', 'WALL_', 'WALL_', '     ', '     ', '     ', '     ', '     ', '     ', '     ', '     ', '     ', '     ', '     ', ],
        ];
        cs.chips = 9;
        cs.player.r = 5;
        cs.player.c = 10;
        cs.tanks.push({r: 1, c: 4, dir: 'U', pi: 0, path: ['D', 'D'], moving: false, reverse: false});
        cs.tanks.push({r: 5, c: 4, dir: 'U', pi: 0, path: ['D', 'D'], moving: false, reverse: false});
   } else if (n == 5) {
        cs.map = [
            ['WALL_', 'WALL_', 'WALL_', 'WALL_', 'WALL_', 'WALL_', 'WALL_', 'WALL_', 'WALL_', 'WALL_', 'WALL_', '     ', '     ', ],
            ['WALL_', 'END__', 'BOMB_', '     ', '     ', '     ', '     ', '     ', '     ', '     ', 'WALL_', '     ', '     ', ],
            ['WALL_', 'WALL_', 'WALL_', '     ', '     ', 'BOMB_', 'BOMB_', 'BOMB_', '     ', '     ', 'WALL_', '     ', '     ', ],
            ['     ', '     ', 'WALL_', '     ', '     ', '     ', '     ', 'BOMB_', '     ', '     ', 'WALL_', '     ', '     ', ],
            ['     ', '     ', 'WALL_', '     ', '     ', 'BOMB_', 'BOMB_', 'BOMB_', '     ', '     ', 'WALL_', '     ', '     ', ],
            ['     ', '     ', 'WALL_', '     ', '     ', 'BOMB_', 'BOMB_', 'BOMB_', '     ', '     ', 'WALL_', '     ', '     ', ],
            ['     ', '     ', 'WALL_', '     ', '     ', '     ', '     ', 'BOMB_', '     ', '     ', 'WALL_', '     ', '     ', ],
            ['     ', '     ', 'WALL_', '     ', '     ', 'BOMB_', 'BOMB_', 'BOMB_', '     ', '     ', 'WALL_', '     ', '     ', ],
            ['     ', '     ', 'WALL_', 'WALL_', 'LOCKR', 'WALL_', 'WALL_', 'WALL_', 'WALL_', 'WALL_', 'WALL_', 'WALL_', 'WALL_', ],
            ['     ', '     ', 'WALL_', '     ', '     ', '     ', 'BUTNG', '     ', '     ', '     ', '     ', '     ', 'WALL_', ],
            ['     ', '     ', 'WALL_', '     ', 'WALL_', 'WALL_', 'WALL_', 'WALL_', 'WALL_', '     ', 'WALL_', '     ', 'WALL_', ],
            ['     ', '     ', 'WALL_', '     ', '     ', '     ', 'BRDRF', '     ', 'BUTNR', '     ', 'WALL_', '     ', 'WALL_', ],
            ['     ', '     ', 'WALL_', 'WALL_', 'WALL_', 'WALL_', 'WALL_', 'WALL_', 'WALL_', 'WALL_', 'WALL_', '     ', 'WALL_', ],
            ['     ', '     ', 'WALL_', 'WATER', 'KEYR1', 'FIRE_', '     ', '     ', '     ', '     ', '     ', '     ', 'WALL_', ],
            ['     ', '     ', 'WALL_', 'WATER', '     ', 'FIRE_', '     ', '     ', '     ', '     ', 'HELP_', '     ', 'WALL_', ],
            ['     ', '     ', 'WALL_', 'WATER', '     ', 'FIRE_', '     ', '     ', '     ', '     ', '     ', '     ', 'WALL_', ],
            ['     ', '     ', 'WALL_', '     ', '     ', '     ', '     ', '     ', '     ', '     ', '     ', '     ', 'WALL_', ],
            ['     ', '     ', 'WALL_', 'WALL_', 'WALL_', 'WALL_', 'WALL_', 'WALL_', 'WALL_', 'WALL_', 'WALL_', 'WALL_', 'WALL_', ],
        ];
        cs.chips = 0;
        cs.player.r = 15;
        cs.player.c = 10;
    } else {
        // END GAME?
        goToLevel(1);
    }

    // TODO: use camera
    cs.camera = {};
    cs.camera.r = cs.player.r;
    cs.camera.c = cs.player.c;
}

function restartLevel()
{
    goToLevel(cs.level);
}

function nextLevel()
{
    goToLevel(cs.level+1);
}

function prevLevel()
{
    goToLevel(cs.level-1);
}

function reset(level = 1) {
    resize();
    pressed = {};
    paused = false;
    //recording = false;
    //playback = false;
    editor_mode = false;
    advanceFrame = false;
    accumulator = 0;
    frameCount = 0;
    prevTime = 0;

    cs = {
        level: level,
        timer: TIMER_INTERVAL_MS,
        dir_timer: 0,
    };

    goToLevel(cs.level);
}

reset();
saveState();

function px(x, f=0.0) { return Math.round(x) + f; }

function worldToScreen(coord) {
    return {
        x: width/2 + coord.x*sq - nc*sq/2,
        y: height/2 + coord.y*sq - nr*sq/2,
        w: coord.w * sq,
        h: coord.h * sq,
    };
}

function drawRect(style, rect) {
    ctx.fillStyle = style;
    const sr = worldToScreen(rect);
    ctx.fillRect(px(sr.x), px(sr.y), sr.w, sr.h);
}

function drawTexture(tex, rect) {
    const sr = worldToScreen(rect);
    ctx.drawImage(tex, px(sr.x), px(sr.y), sr.w, sr.h);
}

function drawText(r, c, text, fill="white", stroke="black", size=50)
{
    const tr = worldToScreen({x: c, y: r, w: 1, h: 1});
    ctx.font = `${size}px Calibri`;
    ctx.lineWidth = 2;
    ctx.fillStyle = fill;
    ctx.strokeStyle = stroke;
    if (fill) ctx.fillText(text, tr.x, tr.y);
    if (stroke) ctx.strokeText(text, tr.x, tr.y);
}

function drawTextCenter(text) { drawText(Math.floor(nr/2), Math.floor(nc/2)-2, text); }

function draw() {
    ctx.clearRect(0, 0, width, height);

    for (let r = 0; r < nr; r++) {
        for (let c = 0; c < nc; c++) {
            const rm = cs.player.r - Math.floor(nr/2) + r;
            const cm = cs.player.c - Math.floor(nc/2) + c;
            let m;
            if (rm < 0 || cm < 0 || rm >= cs.map.length || cm >= cs.map[0].length) m = null;
            else m = cs.map[rm][cm];
            let tex = null;
            if      (m === null)    tex = help_tex;
            else if (m == 'BALL')   tex = ball_tex;
            else if (m == 'BLOCK')  tex = block_tex;
            else if (m == 'BK_CP')  tex = block_tex;
            else if (m == 'BK_FR')  tex = block_tex;
            else if (m == 'X')      tex = blue_creature_tex;
            else if (m == 'X')      tex = blue_creature_down_tex;
            else if (m == 'X')      tex = blue_creature_left_tex;
            else if (m == 'X')      tex = blue_creature_right_tex;
            else if (m == 'BOMB_')  tex = bomb_tex;
            else if (m == 'FLIP_')  tex = boot_flipper_tex;
            else if (m == 'BOOTG')  tex = boot_green_tex;
            else if (m == 'BOOTR')  tex = boot_red_tex;
            else if (m == 'SKATE')  tex = boot_skate_tex;
            else if (m == 'BRDRE')  tex = border_empty_tex;
            else if (m == 'BRDRF')  tex = border_full_tex;
            else if (m == 'X')      tex = button_big_brown_tex;
            else if (m == 'X')      tex = button_big_cyan_tex;
            else if (m == 'X')      tex = button_big_gray_tex;
            else if (m == 'BUTNB')  tex = button_blue_tex;
            else if (m == 'X')      tex = button_brown_tex;
            else if (m == 'BUTNG')  tex = button_green_tex;
            else if (m == 'BUTNR')  tex = button_red_tex;
            else if (m == 'CHIP_')  tex = chip_tex;
            else if (m == 'END__')  tex = end_tex;
            else if (m == 'FIRE_')  tex = fire_tex;
            else if (m == '     ')  tex = floor_tex;
            else if (m == 'X')      tex = floor_edge_tex;
            else if (m == 'X')      tex = gravel_tex;
            else if (m == 'HELP_')  tex = help_tex;
            else if (m == 'ICE__')  tex = ice_tex;
            else if (m == 'ICEUL')  tex = ice_ul_tex;
            else if (m == 'ICELL')  tex = ice_ll_tex;
            else if (m.substr(0,4) == 'KEYC')  tex = key_cyan_tex;
            else if (m.substr(0,4) == 'KEYG')  tex = key_green_tex;
            else if (m.substr(0,4) == 'KEYR')  tex = key_red_tex;
            else if (m.substr(0,4) == 'KEYY')  tex = key_yellow_tex;
            else if (m == 'LOCKC')  tex = lock_cyan_tex;
            else if (m == 'LOCKG')  tex = lock_green_tex;
            else if (m == 'LOCKR')  tex = lock_red_tex;
            else if (m == 'LOCKY')  tex = lock_yellow_tex;
            else if (m == 'X')      tex = missile_tex;
            else if (m == 'X')      tex = missile_shooter_tex;
            else if (m == 'X')      tex = monster_back_tex;
            else if (m == 'X')      tex = monster_front_tex;
            else if (m == 'X')      tex = monster_left_tex;
            else if (m == 'X')      tex = monster_right_tex;
            else if (m == 'X')      tex = player_back_tex;
            else if (m == 'PLAY')   tex = player_front_tex;
            else if (m == 'X')      tex = player_left_tex;
            else if (m == 'X')      tex = player_right_tex;
            else if (m == 'PUSHR')  tex = push_right_tex;
            else if (m == 'PUSHL')  tex = push_left_tex;
            else if (m == 'PUSHU')  tex = push_up_tex;
            else if (m == 'PUSHD')  tex = push_down_tex;
            else if (m == 'RAFT_')  tex = raft_tex;
            else if (m == 'X')      tex = ray_tex;
            else if (m == 'SOCK_')  tex = socket_tex;
            else if (m == 'X')      tex = thief_tex;
            else if (m == 'X')      tex = swim_back_tex;
            else if (m == 'X')      tex = swim_front_tex;
            else if (m == 'X')      tex = swim_left_tex;
            else if (m == 'X')      tex = swim_right_tex;
            else if (m == 'WALL_')  tex = wall_tex;
            else if (m == 'X')      tex = wall_blue_tex;
            else if (m == 'WASP_')  tex = wasp_tex;
            else if (m == 'WATER')  tex = water_tex;
            else                    tex = help_tex;

            drawTexture(tex, {x: c, y: r, w: 1, h: 1});
        }
    }

    let player_tex = player_front_tex;
    const player_tile = cs.map[cs.player.r][cs.player.c];

    if (player_tile == '     ') {
        if (cs.player.dir == ' ')
            player_tex = player_front_tex;
        else if (cs.player.dir == 'U')
            player_tex = player_back_tex;
        else if (cs.player.dir == 'D')
            player_tex = player_front_tex;
        else if (cs.player.dir == 'L')
            player_tex = player_left_tex;
        else if (cs.player.dir == 'R')
            player_tex = player_right_tex;
    } else if (player_tile == 'WATER') {
        if (cs.player.dir == ' ')
            player_tex = swim_front_tex;
        else if (cs.player.dir == 'U')
            player_tex = swim_back_tex;
        else if (cs.player.dir == 'D')
            player_tex = swim_front_tex;
        else if (cs.player.dir == 'L')
            player_tex = swim_left_tex;
        else if (cs.player.dir == 'R')
            player_tex = swim_right_tex;
    } else if (player_tile.substr(0,3) == 'ICE') {
        if (cs.player.dir == ' ')
            player_tex = player_ice_front_tex;
        else if (cs.player.dir == 'U')
            player_tex = player_ice_back_tex;
        else if (cs.player.dir == 'D')
            player_tex = player_ice_front_tex;
        else if (cs.player.dir == 'L')
            player_tex = player_ice_left_tex;
        else if (cs.player.dir == 'R')
            player_tex = player_ice_right_tex;
    }

    drawTexture(player_tex, {x: Math.floor(nc/2), y: Math.floor(nr/2), w: 1, h: 1});

    for (const tank of cs.tanks) {
        const rt = Math.floor(nr/2) + tank.r - cs.player.r;
        const ct = Math.floor(nc/2) + tank.c - cs.player.c;
        if (rt < 0 || rt >= nr || ct < 0 || ct >= nc)
            continue;
        // TODO: choose tank_tex based on tank.dir
        drawTexture(blue_creature_tex, {x: ct, y: rt, w: 1, h: 1});
    }

    for (const wasp of cs.wasps) {
        const rw = Math.floor(nr/2) + wasp.r - cs.player.r;
        const cw = Math.floor(nc/2) + wasp.c - cs.player.c;
        if (rw < 0 || rw >= nr || cw < 0 || cw >= nc)
            continue;
        // TODO: choose wasp_tex based on wasp.dir
        drawTexture(wasp_tex, {x: cw, y: rw, w: 1, h: 1});
    }

    if (recording)
        drawText(0, (nc/2)-3, "RECORDING");
    if (playback)
        drawText(0, (nc/2)-3, "PLAYBACK");
    if (paused)
        drawTextCenter("PAUSED");
    if (editor_mode) {
        drawText(0, (nc/2)-3, "EDITOR");
        const sel_cmin = Math.min(editor_selection.ca, editor_selection.cb);
        const sel_rmin = Math.min(editor_selection.ra, editor_selection.rb);
        const sel_w = Math.abs(editor_selection.cb - editor_selection.ca) + 1;
        const sel_h = Math.abs(editor_selection.rb - editor_selection.ra) + 1;
        drawRect("hsla(240, 50%, 50%, 0.5)", {x: sel_cmin, y: sel_rmin, w: sel_w, h: sel_h});

        let tr=0, tc=-Math.ceil(textures.length/nr)-1;
        for (const ti in textures) {
            const tex = textures[ti];
            drawTexture(tex, {x: tc, y: tr, w: 1, h: 1});
            tr = (tr+1) % nr;
            if (tr == 0)
                tc++;
        }
    }
}

function canGo(dr, dc)
{
    const r = cs.player.r + dr;
    const c = cs.player.c + dc;
    const r2 = cs.player.r + 2*dr;
    const c2 = cs.player.c + 2*dc;

    if (cs.map[r][c] == 'BLOCK' || cs.map[r][c].substr(0,3) == 'BK_') {
        if (cs.map[r2][c2] == '     ')
            return true;
        else if (cs.map[r2][c2] == 'WATER')
            return true;
        else
            return false;
    }

    if (cs.map[r][c] == 'BRDRF')
        return false;

    if (cs.map[r][c] == 'WALL_')
        return false;

    if (cs.map[r][c] == 'LOCKR' && cs.player.keyr == 0)
        return false;
    if (cs.map[r][c] == 'LOCKY' && cs.player.keyy == 0)
        return false;
    if (cs.map[r][c] == 'LOCKC' && cs.player.keyc == 0)
        return false;
    if (cs.map[r][c] == 'LOCKG' && cs.player.keyg == 0)
        return false;

    if (cs.map[r][c] == 'SOCK_' && cs.chips > 0)
        return false;

    return true;
}

function move(dr, dc)
{
    const r = cs.player.r + dr;
    const c = cs.player.c + dc;
    const r2 = cs.player.r + 2*dr;
    const c2 = cs.player.c + 2*dc;

    if (cs.map[r][c].substr(0,4) == 'LOCK') {
        const color = cs.map[r][c].substr(4,1);
        if      (color == 'C') cs.player.keyc--;
        else if (color == 'G') cs.player.keyg--;
        else if (color == 'R') cs.player.keyr--;
        else if (color == 'Y') cs.player.keyy--;
        cs.map[r][c] = '     ';
    }

    if (cs.map[r][c] == 'BOOTR') {
        cs.map[r][c] = '     ';
        cs.player.boot_red = true;
    }
    if (cs.map[r][c] == 'BOOTG') {
        cs.map[r][c] = '     ';
        cs.player.boot_green = true;
    }
    if (cs.map[r][c] == 'FLIP_') {
        cs.map[r][c] = '     ';
        cs.player.boot_flipper = true;
    }
    if (cs.map[r][c] == 'SKATE') {
        cs.map[r][c] = '     ';
        cs.player.boot_skate = true;
    }

    // keys
    if (cs.map[r][c].substr(0,3) == 'KEY') {
        const color = cs.map[r][c].substr(3,1);
        const n = parseInt(cs.map[r][c].substr(4,1));
        if      (color == 'C') cs.player.keyc += n;
        else if (color == 'G') cs.player.keyg += n;
        else if (color == 'R') cs.player.keyr += n;
        else if (color == 'Y') cs.player.keyy += n;
        cs.map[r][c] = '     ';
    }

    if (cs.map[r][c] == 'RAFT_') {
        cs.map[r][c] = '     ';
    }

    if (cs.map[r][c] == 'BLOCK') {
        cs.map[r][c] = '     ';
        if (cs.map[r2][c2] == 'WATER')
            cs.map[r2][c2] = 'RAFT_';
        else
            cs.map[r2][c2] = 'BLOCK';
    }

    // BLOCKs with things underneath
    if (cs.map[r][c].substr(0,3) == 'BK_') {
        if (cs.map[r][c] == 'BK_CP') {
            cs.map[r][c] = 'CHIP_'; // TODO: make it more obvious that a chip was picked up
        } else if (cs.map[r][c] == 'BK_FR') {
            cs.map[r][c] = 'FIRE_';
        }
        if (cs.map[r2][c2] == 'WATER')
            cs.map[r2][c2] = 'RAFT_';
        else
            cs.map[r2][c2] = 'BLOCK';
    }

    if (cs.map[r][c] == 'BUTNB') {
        for (const tank of cs.tanks)
            tank.moving = true;
    }

    if (cs.map[r][c] == 'BUTNR') {
        console.log('TODO: red button');
    }

    if (cs.map[r][c] == 'BUTNG') {
        for (let rx = 0; rx < cs.map.length; rx++) {
            for (let cx = 0; cx < cs.map[0].length; cx++) {
                if      (cs.map[rx][cx] == 'BRDRE') cs.map[rx][cx] = 'BRDRF';
                else if (cs.map[rx][cx] == 'BRDRF') cs.map[rx][cx] = 'BRDRE';
            }
        }
    }

    if (cs.map[r][c] == 'THIEF') {
        cs.player.keyr = 0;
        cs.player.keyg = 0;
        cs.player.keyy = 0;
        cs.player.keyc = 0;
        cs.boot_red = false;
        cs.boot_green = false;
        cs.boot_flipper = false;
        cs.boot_skate = false;
    }

    cs.player.r = r;
    cs.player.c = c;
    if      (dr > 0) cs.player.dir = 'D';
    else if (dr < 0) cs.player.dir = 'U';
    else if (dc > 0) cs.player.dir = 'R';
    else if (dc < 0) cs.player.dir = 'L';
}

function handleInput(t, dt) {

    // don't allow movement while on ice; TODO: is this right?
    const player_tile = cs.map[cs.player.r][cs.player.c];
    if (player_tile.substr(0,3) == 'ICE' && !cs.player.boot_skate)
        return;

    let dr = 0, dc = 0;

    let arrow_key_pressed = pressed.ArrowLeft || pressed.ArrowRight || pressed.ArrowUp || pressed.ArrowDown;

    if (arrow_key_pressed && cs.dir_timer <= 0) {
        if (pressed.ArrowLeft)  { dc = -1; }
        if (pressed.ArrowRight) { dc =  1; }
        if (pressed.ArrowUp)    { dr = -1; }
        if (pressed.ArrowDown)  { dr =  1; }
        cs.dir_timer = DIR_TIMER_MS;
        pressed = {};
    }

    if (dr != 0 || dc != 0) {
        if (canGo(dr, dc))
            move(dr, dc);
    }

    if (arrow_key_pressed) {
        if (pressed.ArrowLeft)  { cs.player.dir = 'L'; }
        if (pressed.ArrowRight) { cs.player.dir = 'R'; }
        if (pressed.ArrowUp)    { cs.player.dir = 'U'; }
        if (pressed.ArrowDown)  { cs.player.dir = 'D'; }
    }
}

function update(t, dt) {

    const pr = cs.player.r;
    const pc = cs.player.c;

    for (const tank of cs.tanks) {
        if (tank.r == pr && tank.c == pc) {
            alert("Look out for creatures!");
            restartLevel();
            return;
        }
    }

    for (const wasp of cs.wasps) {
        if (wasp.r == pr && wasp.c == pc) {
            alert("Look out for creatures!");
            restartLevel();
            return;
        }
    }

    if (cs.map[pr][pc] == 'FIRE_' && !cs.player.boot_red) {
        alert("Oops! Don't step in the fire without fire boots!");
        restartLevel();
        return;
    }

    if (cs.map[pr][pc] == 'WATER' && !cs.player.boot_flipper) {
        alert("Oops! Chip can't swim without flippers!");
        restartLevel();
        return;
    }

    if (cs.map[pr][pc] == 'CHIP_') {
        cs.map[pr][pc] = '     ';
        cs.chips--;
    }

    if (cs.map[pr][pc] == 'SOCK_') {
        cs.map[pr][pc] = '     ';
    }

    if (cs.map[pr][pc] == 'END__') {
        nextLevel();
        return;
    }

    if (cs.dir_timer > 0) {
        cs.dir_timer -= dt;
    }

    if (cs.timer > 0) {
        cs.timer -= dt;
        return;
    }
    cs.timer += TIMER_INTERVAL_MS;
    // TODO: wasps should only update ever other tick

    for (const tank of cs.tanks) {
        if (!tank.moving)
            continue;
        let d = tank.path[tank.pi];
        if (tank.reverse) {
            if      (d == 'U')  d = 'D';
            else if (d == 'D')  d = 'U';
            else if (d == 'L')  d = 'R';
            else if (d == 'R')  d = 'L';
        }
        if (d == 'U') {
            tank.r--;
            tank.dir = 'U';
        } else if (d == 'L') {
            tank.c--;
            tank.dir = 'L';
        } else if (d == 'R') {
            tank.c++;
            tank.dir = 'R';
        } else if (d == 'D') {
            tank.r++;
            tank.dir = 'D';
        }

        if (tank.reverse)   tank.pi--;
        else                tank.pi++;

        if (tank.pi == tank.path.length) {
            tank.moving = false;
            tank.reverse = true;
            tank.pi--;
        } else if (tank.pi == -1) {
            tank.moving = false;
            tank.reverse = false;
            tank.pi++;
        }
    }

    for (const wasp of cs.wasps) {
        const d = wasp.path[wasp.pi];
        if (d == 'U') {
            wasp.r--;
            wasp.dir = 'U';
        } else if (d == 'L') {
            wasp.c--;
            wasp.dir = 'L';
        } else if (d == 'R') {
            wasp.c++;
            wasp.dir = 'R';
        } else if (d == 'D') {
            wasp.r++;
            wasp.dir = 'D';
        }
        wasp.pi = (wasp.pi + 1) % wasp.path.length;
    }

    const player_tile = cs.map[cs.player.r][cs.player.c];

    if (player_tile.substr(0,3) == 'ICE' && !cs.player.boot_skate) {
        // TODO: move player in direction they were going, redirect at corners
        if (player_tile == 'ICE__') {
            if      (cs.player.dir == 'L') cs.player.c--;
            else if (cs.player.dir == 'R') cs.player.c++;
            else if (cs.player.dir == 'U') cs.player.r--;
            else if (cs.player.dir == 'D') cs.player.r++;
        } else if (player_tile == 'ICEUL') {
            if      (cs.player.dir == 'L') { cs.player.dir = 'D'; cs.player.r++;    }
            else if (cs.player.dir == 'R') { cs.player.dir = ' ';                   }
            else if (cs.player.dir == 'U') { cs.player.dir = 'R'; cs.player.c++;    }
            else if (cs.player.dir == 'D') { cs.player.dir = ' ';                   }
        } else if (player_tile == 'ICELL') {
            if      (cs.player.dir == 'L') { cs.player.dir = 'U'; cs.player.r--;    }
            else if (cs.player.dir == 'R') { cs.player.dir = ' ';                   }
            else if (cs.player.dir == 'U') { cs.player.dir = ' ';                   }
            else if (cs.player.dir == 'D') { cs.player.dir = 'R'; cs.player.c++;    }
        } else if (player_tile == 'ICEUR') {
            console.error('TODO!');
        } else if (player_tile == 'ICELR') {
            console.error('TODO!');
        }
    }

    if (player_tile.substr(0,4) == 'PUSH' && !cs.player.boot_green) {
        if (player_tile == 'PUSHL')
            cs.player.c--;
        else if (player_tile == 'PUSHR')
            cs.player.c++;
        else if (player_tile == 'PUSHU')
            cs.player.r--;
        else if (player_tile == 'PUSHD')
            cs.player.r++;
    }
}

function simulateInputOnFrame(n, verbose=true) {
    if (n in inputsToSim) {
        for (let input of inputsToSim[n]) {
            if (verbose) { console.log(`input '${input.key}' ${input.mode} on frame ${n}`); }
            let e = {key: input.key};
            if (input.mode == 'down')   { keydown(e); }
            else                        { keyup(e); }
        }
    }
}

function loop(t) {
    let frameTime = t - prevTime;
    prevTime = t;

    if (!editor_mode && (!paused || advanceFrame)) {

        if (frameTime > MAX_FRAMETIME) {
            console.log(`frameTime > MAX_FRAMETIME : ${frameTime}`);
            frameTime = MAX_FRAMETIME;
        }

        accumulator += frameTime * simRate;

        while (accumulator >= fixed_dt) {
            frameCount++;
            if (playback) {
                simulateInputOnFrame(frameCount);
                if (frameCount > last_playback_frame)
                    playback = false;
            }
            handleInput(t, fixed_dt);
            update(t, fixed_dt);
            accumulator -= fixed_dt;
        }
        advanceFrame = false;
    }
    draw();
    window.requestAnimationFrame(loop);
}

loop(0);

function blur(e) {
    if (!editor_mode)
        paused = true;
}

function focus(e) {
}

function resize(e) {
    width = canvas.width = window.innerWidth;
    height = canvas.height = window.innerHeight;
    const sqh = Math.round(height/(nr+1));
    const sqw = Math.round(width/(nc+1));
    //sq = Math.min(sqh, sqw);
    sq = 32;
}

function mouse_get_tile_info(x, y)
{
    let rv = {};
    rv.c = Math.floor((x - width/2 + (sq*nc/2))/sq);
    rv.r = Math.floor((y - height/2 + (sq*nr/2))/sq);
    rv.rm = cs.player.r - Math.floor(nr/2) + rv.r;
    rv.cm = cs.player.c - Math.floor(nc/2) + rv.c;
    rv.valid = rv.rm >= 0 && rv.cm >= 0 && rv.rm < cs.map.length && rv.cm < cs.map[0].length;
    rv.m = rv.valid ? rv.m = cs.map[rv.rm][rv.cm] : null;
    return rv;
}

// TODO: finish editor mode behavior
function mousedown(e) {
    if (e.button == LEFT_BUTTON) mouse_down_left = true;

    if (editor_mode) {
        if (e.button != LEFT_BUTTON)
            return;

        editor_selection = {};

        const tile_info = mouse_get_tile_info(e.clientX, e.clientY);
        if (tile_info.valid) {
            editor_selection.rb = editor_selection.ra = tile_info.r;
            editor_selection.cb = editor_selection.ca = tile_info.c;
        }
    }
}

function mouseup(e) {
    if (e.button == LEFT_BUTTON) mouse_down_left = false;
}

function mousemove(e) {
    if (editor_mode) {
        if (!mouse_down_left)
            return;
        const tile_info = mouse_get_tile_info(e.clientX, e.clientY);
        if (tile_info.valid) {
            editor_selection.rb = tile_info.r;
            editor_selection.cb = tile_info.c;
        }
    }
}

function keydown(e) {
    if (!editor_mode) {
        if (e.key === 'Escape') {
            paused = !paused;
        } else if (e.key === 'n') {
            nextLevel();
        } else if (e.key === 'p') {
            prevLevel();
        } else if (e.key === 's') {
            saveState();
        } else if (e.key === 'd') {
            restoreState();
        } else if (e.key === ',' || e.key === '.') {
            if (e.key === ',')
                simRate /= 2;
            else if (e.key === '.')
                simRate *= 2;
            console.log(`simRate: ${simRate}`);
        } else if (e.key === '`') {
            advanceFrame = true;
        } else if (e.key === 'u') {
            // TODO: undo!
        } else if (e.key === 'U') {
            // TODO: redo!
        } else if (e.key === 'e') {
            editor_mode = true;
            editor_selection = {};
            paused = false;
        } else if (e.key === 'R') {
            if (recording) last_playback_frame = frameCount;
            recording = !recording;
            if (recording)  { reset(cs.level); inputsToSim = {}; }
            else            { console.log(inputsToSim); }
        } else if (e.key === 'P') {
            if (!playback)
                reset(cs.level);
            playback = !playback;
        } else if (e.key === 'r') {
            reset(cs.level);
            //restartLevel();
        } else {
            if (recording) {
                if (!(frameCount in inputsToSim))
                    inputsToSim[frameCount] = [];
                inputsToSim[frameCount].push({key: e.key, mode: 'down'});
            }
            pressed[e.key] = true;
        }
    } else {
        if (e.key === 'Escape') {
            editor_selection = {};
        } else if (e.key === 'e') {
            console.log(cs.map); // TODO: output the map
            editor_mode = false;
        } else if (e.key === 'ArrowUp') {
        } else if (e.key === 'ArrowDown') {
        } else if (e.key === 'ArrowLeft') {
        } else if (e.key === 'ArrowRight') {
        } else {
        }
    }
}

function keyup(e) {
    if (!editor_mode) {
        if (e.key === 'Escape') {
        } else if (e.key === 'r') {
        } else {
            if (recording) {
                if (!(frameCount in inputsToSim))
                    inputsToSim[frameCount] = [];
                inputsToSim[frameCount].push({key: e.key, mode: 'up'});
            }
            pressed[e.key] = false;
        }
    } else {
    }
}

window.addEventListener('blur', blur);
window.addEventListener('focus', focus);
window.addEventListener('mousedown', mousedown);
window.addEventListener('mouseup', mouseup);
window.addEventListener('mousemove', mousemove);
window.addEventListener('keydown', keydown);
window.addEventListener('keyup', keyup);
window.addEventListener('resize', resize);

        </script>
    </body>

</html>
